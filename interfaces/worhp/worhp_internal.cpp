/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010 by Joel Andersson, Moritz Diehl, K.U.Leuven. All rights reserved.
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

#include "worhp_internal.hpp"
#include "symbolic/stl_vector_tools.hpp"
#include "symbolic/matrix/matrix_tools.hpp"
#include "symbolic/mx/mx_tools.hpp"
#include "symbolic/matrix/sparsity_tools.hpp"
#include "symbolic/fx/mx_function.hpp"
#include <ctime>

using namespace std;

namespace CasADi{

  WorhpInternal::WorhpInternal(const FX& nlp) : NLPSolverInternal(nlp){

    // Monitors
    addOption("monitor",            OT_STRINGVECTOR,  GenericType(),  "Monitor functions", "eval_f|eval_g|eval_jac_g|eval_grad_f|eval_h", true);
    addOption("print_time",         OT_BOOLEAN,       true,           "Print information about execution time");
  
    int status;
    InitParams(&status, &worhp_p_);
  
    std::stringstream ss;
    ss << "Armijo recovery strategies. Vector of size " << NAres;
  
    std::vector<int> ares(NAres);
    std::copy(worhp_p_.Ares,worhp_p_.Ares+NAres,ares.begin());
    addOption("Ares",OT_INTEGERVECTOR,ares,ss.str());
      
    /**
     *  Autogenerated from C_worhp_aux.h with params.pl
     *
     */
  
    addOption("AcceptTolFeas",OT_REAL,worhp_p_.AcceptTolFeas,"Tolerance for acceptable feasibility");
    addOption("AcceptTolOpti",OT_REAL,worhp_p_.AcceptTolOpti,"Tolerance for acceptable optimality");
    addOption("ArmijoBeta",OT_REAL,worhp_p_.ArmijoBeta,"Trial stepsize decrease factor for Armijo rule");
    addOption("ArmijoMaxAlpha",OT_REAL,worhp_p_.ArmijoMaxAlpha,"Initial alpha for Armijo rule");
    addOption("ArmijoMinAlpha",OT_REAL,worhp_p_.ArmijoMinAlpha,"Lower bound on alpha for Armijo rule");
    addOption("ArmijoMinAlphaRec",OT_REAL,worhp_p_.ArmijoMinAlphaRec,"Lower bound on alpha for Armijo rule during recovery");
    addOption("ArmijoSigma",OT_REAL,worhp_p_.ArmijoSigma,"Scale factor for linearised descent check in Armijo rule");
    addOption("BettsFactor",OT_REAL,worhp_p_.BettsFactor,"Update factor for Betts' Hessian regularisation");
    addOption("BettsPoint",OT_REAL,worhp_p_.BettsPoint,"Smallest eigenvalue of the regularised Hessian");
    addOption("BoundTolFac",OT_REAL,worhp_p_.BoundTolFac,"Factor in determining active constraints by KKT");
    addOption("CorStepBettsSum",OT_REAL,worhp_p_.CorStepBettsSum,"(experimental)");
    addOption("CorStepConvio",OT_REAL,worhp_p_.CorStepConvio,"(experimental)");
    addOption("CorStepConStop",OT_REAL,worhp_p_.CorStepConStop,"(experimental)");
    addOption("CorStepPFactor",OT_REAL,worhp_p_.CorStepPFactor,"(experimental)");
    addOption("CorStepPMax",OT_REAL,worhp_p_.CorStepPMax,"(experimental)");
    addOption("CheckFJ",OT_REAL,worhp_p_.CheckFJ,"Upper bound used by Fritz-John heuristic");
    addOption("CurvBCond",OT_REAL,worhp_p_.CurvBCond,"Block BFGS curvature condition bound");
    addOption("CurvBFac",OT_REAL,worhp_p_.CurvBFac,"Block BFGS curvature condition regularisation factor");
    addOption("CurvCond",OT_REAL,worhp_p_.CurvCond,"BFGS Curvature condition bound");
    addOption("CurvFac",OT_REAL,worhp_p_.CurvFac,"BFGS curvature condition regularisation factor");
    addOption("CutLength",OT_REAL,worhp_p_.CutLength,"Scaling factor for Cut recovery strategy");
    addOption("FeasibleInitTol",OT_REAL,worhp_p_.FeasibleInitTol,"Feasibility tolerance for no-objective feasible mode");
    addOption("FidifEps",OT_REAL,worhp_p_.FidifEps,"Finite difference perturbation");
    addOption("FocusOnFeasFactor",OT_REAL,worhp_p_.FocusOnFeasFactor,"Factor in Focus-on-Feasibility mode");
    addOption("Infty",OT_REAL,worhp_p_.Infty,"Upper bound for numbers to be regarded as finite");
    addOption("InftyUnbounded",OT_REAL,worhp_p_.InftyUnbounded,"Tolerance for unboundedness detection heuristic");
    addOption("LMestQPipComTol",OT_REAL,worhp_p_.LMestQPipComTol,"IP complementarity tolerance in initial multiplier estimate");
    addOption("LMestQPipResTol",OT_REAL,worhp_p_.LMestQPipResTol,"IP residual tolerance in initial multiplier estimate");
    addOption("LowPassAlphaF",OT_REAL,worhp_p_.LowPassAlphaF,"Lowpass-filter update factor for objective values");
    addOption("LowPassAlphaG",OT_REAL,worhp_p_.LowPassAlphaG,"Lowpass-filter update factor for constraint values");
    addOption("LowPassAlphaMerit",OT_REAL,worhp_p_.LowPassAlphaMerit,"Lowpass-filter update factor for merit function values");
    addOption("Ma57PivotThresh",OT_REAL,worhp_p_.Ma57PivotThresh,"Pivoting tolerance for MA57 = CNTL(1)");
    addOption("MeritGradTol",OT_REAL,worhp_p_.MeritGradTol,"Threshold of meritfunction gradient for increasing Hessian regularisation");
    addOption("PenUpdEpsKFac",OT_REAL,worhp_p_.PenUpdEpsKFac,"Penalty update parameter factor for MeritFunction = 4");
    addOption("PenUpdEpsBar",OT_REAL,worhp_p_.PenUpdEpsBar,"Penalty update parameter factor for MeritFunction = 3");
    addOption("PenUpdMaxDeltaK",OT_REAL,worhp_p_.PenUpdMaxDeltaK,"Max penalty for MeritFunction = 4");
    addOption("PenUpdMaxFac",OT_REAL,worhp_p_.PenUpdMaxFac,"Max factor for increasing penalty for MeritFunction = 4");
    addOption("PenUpdRBar",OT_REAL,worhp_p_.PenUpdRBar,"Penalty update parameter for MeritFunction = 3");
    addOption("PrecisionF",OT_REAL,worhp_p_.PrecisionF,"(currently unused) Relative precision of objective");
    addOption("PrecisionG",OT_REAL,worhp_p_.PrecisionG,"(currently unused) Relative precision of constraints");
    addOption("QPscaleParam",OT_REAL,worhp_p_.QPscaleParam,"(currently unused)");
    addOption("RelaxMaxDelta",OT_REAL,worhp_p_.RelaxMaxDelta,"Upper bound for accepting the constraint relaxation variable");
    addOption("RelaxMaxPen",OT_REAL,worhp_p_.RelaxMaxPen,"Upper bound on the constraint relaxation penalty");
    addOption("RelaxRho",OT_REAL,worhp_p_.RelaxRho,"Update factor for the constraint relaxation penalty");
    addOption("RelaxStart",OT_REAL,worhp_p_.RelaxStart,"Initial value of the constraint relaxation penalty");
    addOption("ScaleFacObj",OT_REAL,worhp_p_.ScaleFacObj,"Value to scale large objective functions to");
    addOption("ScaleFacQP",OT_REAL,worhp_p_.ScaleFacQP,"Upper bound on resulting matrix norm for QP scaling");
    addOption("StartBettsTau",OT_REAL,worhp_p_.StartBettsTau,"Initial value for Betts' update dampening term");
    addOption("Timeout",OT_REAL,worhp_p_.Timeout,"Timeout in seconds");
    addOption("TolComp",OT_REAL,worhp_p_.TolComp,"Complementarity tolerance");
    addOption("TolFeas",OT_REAL,worhp_p_.TolFeas,"Feasibility tolerance");
    addOption("TolOpti",OT_REAL,worhp_p_.TolOpti,"Optimality tolerance");
    addOption("TolWeakActive",OT_REAL,worhp_p_.TolWeakActive,"(experimental)");
    addOption("TooBigCV",OT_REAL,worhp_p_.TooBigCV,"Upper bound on constraint violation for too-big heuristic");
    addOption("TooBigKKT",OT_REAL,worhp_p_.TooBigKKT,"Upper bound on KKT values for too-big heuristic");
    addOption("eps",OT_REAL,worhp_p_.eps,"Machine epsilon");
    addOption("IncreaseIWS",OT_REAL,worhp_p_.IncreaseIWS,"Increase factor for estimated integer workspace requirement");
    addOption("IncreaseRWS",OT_REAL,worhp_p_.IncreaseRWS,"Increase factor for estimated real workspace requirement");
    addOption("FilterGammaCV",OT_REAL,worhp_p_.FilterGammaCV,"Constraint violation decrease factor in Filter acceptance check");
    addOption("FilterGammaF",OT_REAL,worhp_p_.FilterGammaF,"Objective decrease factor in Filter acceptance check");
    addOption("GammaAlpha",OT_REAL,worhp_p_.GammaAlpha,"Safety factor for alphamin calculation by Filter");
    addOption("IncBettsTau",OT_REAL,worhp_p_.IncBettsTau,"Increase factor for Betts' update dampening term");
    addOption("IncBettsTauMore",OT_REAL,worhp_p_.IncBettsTauMore,"Larger increase factor for Betts' update dampening term");
    addOption("MinBettsTau",OT_REAL,worhp_p_.MinBettsTau,"Lower bound for Betts' update dampening term");
    addOption("ReduceBettsTau",OT_REAL,worhp_p_.ReduceBettsTau,"Decrease factor for Betts' update dampening term");
    addOption("SwitchingDelta",OT_REAL,worhp_p_.SwitchingDelta,"Filter switching condition parameter");
    addOption("SwitchingSF",OT_REAL,worhp_p_.SwitchingSF,"Filter switching condition parameter");
    addOption("SwitchingSCV",OT_REAL,worhp_p_.SwitchingSCV,"Filter switching condition parameter");
    addOption("BFGSmethod",OT_INTEGER,worhp_p_.BFGSmethod,"Choose BFGS method (dense, block, sparse)");
    addOption("BFGSrestart",OT_INTEGER,worhp_p_.BFGSrestart,"Restart BFGS update after this many iterations");
    addOption("BFGSmaxblockSize",OT_INTEGER,worhp_p_.BFGSmaxblockSize,"Maximum BFGS block size (depends on BFGS method)");
    addOption("BFGSminblockSize",OT_INTEGER,worhp_p_.BFGSminblockSize,"Minimum BFGS block size (depends on BFGS method)");
    addOption("CorStepMaxIter",OT_INTEGER,worhp_p_.CorStepMaxIter,"(experimental)");
    addOption("CorStepMethod",OT_INTEGER,worhp_p_.CorStepMethod,"(experimental)");
    addOption("CorStepMode",OT_INTEGER,worhp_p_.CorStepMode,"(experimental)");
    addOption("GroupMethod",OT_INTEGER,worhp_p_.GroupMethod,"Select method to determine graph colouring groups");
    addOption("LogLevel",OT_INTEGER,worhp_p_.LogLevel,"Enable XML logfiles and writing interval");
    addOption("LogResult",OT_INTEGER,worhp_p_.LogResult,"Enable XML result logging and detail level");
    addOption("MaxCalls",OT_INTEGER,worhp_p_.MaxCalls,"Upper bound to Reverse Communication calls");
    addOption("MaxForce",OT_INTEGER,worhp_p_.MaxForce,"Maximum number of Force recovery strategy steps");
    addOption("MaxGPart",OT_INTEGER,worhp_p_.MaxGPart,"(experimental)");
    addOption("MaxIter",OT_INTEGER,worhp_p_.MaxIter,"Upper bound on major iterations");
    addOption("MeritFunction",OT_INTEGER,worhp_p_.MeritFunction,"Select merit function and penalty update [0, 3..5]");
    addOption("NLPmethod",OT_INTEGER,worhp_p_.NLPmethod,"Select (1) Meritfunction or (3) Filter globalisation");
    addOption("NLPprint",OT_INTEGER,worhp_p_.NLPprint,"NLP print level [-1..4]");
    addOption("PairMethod",OT_INTEGER,worhp_p_.PairMethod,"Select method to determine graph colouring pairgroups");
    addOption("PenUpdEpsKSequence",OT_INTEGER,worhp_p_.PenUpdEpsKSequence,"Penalty update parameter");
    addOption("UserHMstructure",OT_INTEGER,worhp_p_.UserHMstructure,"Enable automatic Hessian structure generation or checking");
    addOption("MaxLScounter",OT_INTEGER,worhp_p_.MaxLScounter,"Control activation of Filter acceleration heuristics");
    addOption("RegStrategy",OT_INTEGER,worhp_p_.RegStrategy,"Select Hessian regularisation strategy in Filter");
    addOption("AutoQPRecovery",OT_BOOLEAN,worhp_p_.AutoQPRecovery,"Enable automatic QP recovery");
    addOption("CheckStructureDF",OT_BOOLEAN,worhp_p_.CheckStructureDF,"Enable structural checking of DF");
    addOption("CheckStructureDG",OT_BOOLEAN,worhp_p_.CheckStructureDG,"Enable structural checking of DG");
    addOption("CheckStructureHM",OT_BOOLEAN,worhp_p_.CheckStructureHM,"Enable structural checking of HM");
    addOption("CorStepRecoveryDX",OT_BOOLEAN,worhp_p_.CorStepRecoveryDX,"Enable structural checking of HM");
    addOption("FGtogether",OT_BOOLEAN,worhp_p_.FGtogether,"F and G cannot be evaluated separately");
    addOption("FJandND",OT_BOOLEAN,worhp_p_.FJandND,"Enable Fritz-John and non-differentiable check heuristics");
    addOption("FeasibleDual",OT_BOOLEAN,worhp_p_.FeasibleDual,"Activate dual feasibility mode");
    addOption("FeasibleInit",OT_BOOLEAN,worhp_p_.FeasibleInit,"Activate initial feasibility mode");
    addOption("FeasibleOnly",OT_BOOLEAN,worhp_p_.FeasibleOnly,"Activate feasible-only mode");
    addOption("FidifHM",OT_BOOLEAN,worhp_p_.FidifHM,"Approximate Hessian by finite differences (otherwise BFGS)");
    addOption("FirstDifCentral",OT_BOOLEAN,worhp_p_.FirstDifCentral,"Use central finite difference quotient for first derivatives");
    addOption("FocusOnFeas",OT_BOOLEAN,worhp_p_.FocusOnFeas,"Enable Focus-on-Feasibility mode");
    addOption("InitialLMest",OT_BOOLEAN,worhp_p_.InitialLMest,"Enable initial Lagrange multiplier estimate");
    addOption("KeepAcceptableSol",OT_BOOLEAN,worhp_p_.KeepAcceptableSol,"Save acceptable solutions as fallback");
    addOption("LinMult",OT_BOOLEAN,worhp_p_.LinMult,"Control Lagrange multiplier update");
    addOption("LowPassFilter",OT_BOOLEAN,worhp_p_.LowPassFilter,"Enable lowpass-filter termination criterion");
    addOption("MatrixCC",OT_BOOLEAN,worhp_p_.MatrixCC,"Not to be included into a parameter file!");
    addOption("MoreRelax",OT_BOOLEAN,worhp_p_.MoreRelax,"Introduce one relaxation variable for every constraint");
    addOption("QuadraticProblem",OT_BOOLEAN,worhp_p_.QuadraticProblem,"Not to be included into a parameter file!");
    addOption("RestUntilFeas",OT_BOOLEAN,worhp_p_.RestUntilFeas,"Do restoration until a feasible solution is found");
    addOption("ScaleConIter",OT_BOOLEAN,worhp_p_.ScaleConIter,"Scale constraints in every iteration");
    addOption("ScaledFD",OT_BOOLEAN,worhp_p_.ScaledFD,"Use a scaled perturbation for finite differences");
    addOption("ScaledKKT",OT_BOOLEAN,worhp_p_.ScaledKKT,"Scale KKT conditions");
    addOption("ScaledObj",OT_BOOLEAN,worhp_p_.ScaledObj,"Scale the objective function");
    addOption("ScaledQP",OT_BOOLEAN,worhp_p_.ScaledQP,"Scale some matrices handed to the QP");
    addOption("TakeQPSol",OT_BOOLEAN,worhp_p_.TakeQPSol,"Evaluate QP search direction regardless of convergence");
    addOption("TooBig",OT_BOOLEAN,worhp_p_.TooBig,"Enable too-big termination heuristics");
    addOption("UserDF",OT_BOOLEAN,worhp_p_.UserDF,"Objective gradient values supplied by caller");
    addOption("UserDG",OT_BOOLEAN,worhp_p_.UserDG,"Jacobian values supplied by caller");
    addOption("UserHM",OT_BOOLEAN,worhp_p_.UserHM,"Hessian values supplied by caller");
    addOption("WeakActiveSet",OT_BOOLEAN,worhp_p_.WeakActiveSet,"(experimental)");
    addOption("AlphaMinConst",OT_BOOLEAN,worhp_p_.AlphaMinConst,"Use a constant lower bound on Armijo stepsize in Filter");
    addOption("IgnoreFilterCrit",OT_BOOLEAN,worhp_p_.IgnoreFilterCrit,"Activate accelerating heuristics for Filter");
    addOption("FilterBisecAlpha",OT_BOOLEAN,worhp_p_.FilterBisecAlpha,"Filter heuristic to save Armijo iterations");
    addOption("FilterIntersecAlpha",OT_BOOLEAN,worhp_p_.FilterIntersecAlpha,"Filter heuristic to save Armijo iterations");
    addOption("MaxNorm",OT_BOOLEAN,worhp_p_.MaxNorm,"Select max-norm instead of 1-norm in Filter");
    addOption("ReinitFilter",OT_BOOLEAN,worhp_p_.ReinitFilter,"Enables Filter-reinitialisation accelerating heuristic");
    addOption("DebugMarker06",OT_INTEGER,worhp_p_.DebugMarker06,"Debug marker, only needed for ASTOS integration");
    addOption("initialised",OT_BOOLEAN,worhp_p_.initialised,"Automatically added initialisation flag. ");
  
    addOption("qp_ipBarrier",OT_REAL,worhp_p_.qp.ipBarrier,"IP barrier parameter.");
    addOption("qp_ipComTol",OT_REAL,worhp_p_.qp.ipComTol,"IP complementarity tolerance.");
    addOption("qp_ipFracBound",OT_REAL,worhp_p_.qp.ipFracBound,"IP fraction-to-the-boundary parameter.");
    addOption("qp_ipLsMethod",OT_STRING,GenericType(),"Select the direct linear solver used by the IP method.","LAPACK::0|MA57: only available if provided by the user:1|SuperLU::2|PARDISO: only available if provided by the user, subject to license availability:3|MUMPS: currently Linux platforms only:5|WSMP: subject to license availability:6|MA86: experimental, only available if provided by the user:7|MA97:experimental, only available if provided by the user:8");
    setOptionByEnumValue("qp_ipLsMethod",worhp_p_.qp.ipLsMethod);
    addOption("qp_ipMinAlpha",OT_REAL,worhp_p_.qp.ipMinAlpha,"IP line search minimum step size.");
    addOption("qp_ipTryRelax",OT_BOOLEAN,worhp_p_.qp.ipTryRelax,"Enable relaxation strategy when encountering an error.");
    addOption("qp_ipRelaxDiv",OT_REAL,worhp_p_.qp.ipRelaxDiv,"The relaxation term is divided by this value if successful.");
    addOption("qp_ipRelaxMult",OT_REAL,worhp_p_.qp.ipRelaxMult,"The relaxation term is multiplied by this value if unsuccessful.");
    addOption("qp_ipRelaxMax",OT_REAL,worhp_p_.qp.ipRelaxMax,"Maximum relaxation value.");
    addOption("qp_ipRelaxMin",OT_REAL,worhp_p_.qp.ipRelaxMin,"Mimimum relaxation value.");
    addOption("qp_ipResTol",OT_REAL,worhp_p_.qp.ipResTol,"IP residuals tolerance.");
    addOption("qp_lsItMaxIter",OT_INTEGER,worhp_p_.qp.lsItMaxIter,"Maximum number of iterations of the iterative linear solvers.");
    addOption("qp_lsItMethod",OT_STRING,GenericType(),"Select the iterative linear solver.","none:Deactivate; use a direct linear solver.:0|CGNR::1|CGNE::2|CGS::3|BiCGSTAB::4");
    setOptionByEnumValue("qp_lsItMethod",worhp_p_.qp.lsItMethod);
    addOption("qp_lsItPrecondMethod",OT_STRING,GenericType(),"Select preconditioner for the iterative linear solver.","none:No preconditioner.:0|static:Static preconditioner (KKT-matrix with constant lower-right block).:1|full:Full KKT-matrix.:2");
    setOptionByEnumValue("qp_lsItPrecondMethod",worhp_p_.qp.lsItPrecondMethod);
    addOption("qp_lsRefineMaxIter",OT_INTEGER,worhp_p_.qp.lsRefineMaxIter,"Maximum number of iterative refinement steps of the direct linear solvers.");
    addOption("qp_lsScale",OT_BOOLEAN,worhp_p_.qp.lsScale,"Enables scaling on linear solver level.");
    addOption("qp_lsTrySimple",OT_BOOLEAN,worhp_p_.qp.lsTrySimple,"Some matrices can be solved without calling a linear equation solver.Currently only diagonal matrices are supported. Non-diagonal matrices will besolved with the chosen linear equation solver.");
    addOption("qp_lsTol",OT_REAL,worhp_p_.qp.lsTol,"Tolerance for the linear solver.");
    addOption("qp_maxIter",OT_INTEGER,worhp_p_.qp.maxIter,"Imposes an upper limit on the number of minor solver iterations, i.e. for thequadratic subproblem solver. If the limit is reached before convergence,WORHP will activate QP recovery strategies to prevent a solver breakdown.");
    addOption("qp_method",OT_STRING,GenericType(),"Select the solution method used by the QP solver.","ip:Interior-Point method.:1|nsn:Nonsmooth-Newton method.:2|automatic: Prefer IP and fall back to NSN on error.:12");
    setOptionByEnumValue("qp_method",worhp_p_.qp.method);
    addOption("qp_nsnBeta",OT_REAL,worhp_p_.qp.nsnBeta,"NSN stepsize decrease factor.");
    addOption("qp_nsnGradStep",OT_BOOLEAN,worhp_p_.qp.nsnGradStep,"Enable gradient steps in the NSN method.");
    addOption("qp_nsnKKT",OT_REAL,worhp_p_.qp.nsnKKT,"NSN KKT tolerance.");
    addOption("qp_nsnLsMethod",OT_STRING,GenericType(),"Select the direct linear solver used by the NSN method.","SuperLU::2|MA48: only available if provided by the user:4");
    setOptionByEnumValue("qp_nsnLsMethod",worhp_p_.qp.nsnLsMethod);
    addOption("qp_nsnMinAlpha",OT_REAL,worhp_p_.qp.nsnMinAlpha,"NSN line search minimum step size.");
    addOption("qp_nsnSigma",OT_REAL,worhp_p_.qp.nsnSigma,"NSN line search slope parameter.");
    addOption("qp_printLevel",OT_STRING,GenericType(),"Controls the amount of QP solver output.","none:No output.:0|warn:Print warnings and errors.:1|iterations:Print iterations.:2");
    setOptionByEnumValue("qp_printLevel",worhp_p_.qp.printLevel);
    addOption("qp_scaleIntern",OT_BOOLEAN,worhp_p_.qp.scaleIntern,"Enable scaling on QP level.");
    addOption("qp_strict",OT_BOOLEAN,worhp_p_.qp.strict,"Use strict termination criteria in IP method.");
  
    worhp_o_.initialised = false;
    worhp_w_.initialised = false;
    worhp_p_.initialised = false;
    worhp_c_.initialised = false;
  
    // WORKAROUND: Bug in scaling, set to false by default // FIXME
    setOption("ScaledObj",false);

    // WORKAROUND: Why is this needed? // FIXME
    setOption("ScaleConIter",true);
  }

  WorhpInternal::~WorhpInternal(){
    if (worhp_p_.initialised || worhp_o_.initialised || worhp_w_.initialised || worhp_c_.initialised)
      WorhpFree(&worhp_o_, &worhp_w_, &worhp_p_, &worhp_c_);
  }

  WorhpInternal* WorhpInternal::clone() const{ 
    // Use default copy routine
    WorhpInternal* node = new WorhpInternal(*this);
    
    // Mark Worhp datastructures not initialized to avoid double freeing
    node->worhp_o_.initialised = false;
    node->worhp_w_.initialised = false;
    node->worhp_p_.initialised = false;
    node->worhp_c_.initialised = false;    
    
    return node;
  }

  void WorhpInternal::init(){

    // Call the init method of the base class
    NLPSolverInternal::init();

    if (hasSetOption("Ares")) {
      std::vector<int> ares = getOption("Ares");
      std::copy(ares.begin(),ares.begin()+NAres,worhp_p_.Ares);
    }
  
    // Read options
    passOptions();
  
    // Exact Hessian?
    exact_hessian_ = getOption("UserHM");

    // Get/generate required functions
    gradF();
    jacG();
    if(exact_hessian_){ // does not appear to work
      hessLag();
    }

    /// Sparsity pattern for the transpose of the Jacobian of the constraints
    if(ng_>0){
      spJacG_T_ = jacG().output(JACG_JAC).sparsity().transpose();
      jacG_tmp_.resize(ng_+1);
    }

    // Update status?
    status_[TerminateSuccess]="TerminateSuccess";
    status_[OptimalSolution]="OptimalSolution";
    status_[SearchDirectionZero]="SearchDirectionZero";
    status_[SearchDirectionSmall]="SearchDirectionSmall";
    status_[StationaryPointFound]="StationaryPointFound";
    status_[AcceptableSolution]="AcceptableSolution";
    status_[AcceptablePrevious]="AcceptablePrevious";
    status_[FritzJohn]="FritzJohn";
    status_[NotDiffable]="NotDiffable";
    status_[Unbounded]="Unbounded";
    status_[FeasibleSolution]="FeasibleSolution";
    status_[LowPassFilterOptimal]="LowPassFilterOptimal";
    status_[LowPassFilterAcceptable]="LowPassFilterAcceptable";
    status_[TerminateError]="TerminateError";
    status_[InitError]="InitError";
    status_[DataError]="DataError";
    status_[MaxCalls]="MaxCalls";
    status_[MaxIter]="MaxIter";
    status_[MinimumStepsize]="MinimumStepsize";
    status_[QPerror]="QPerror";
    status_[ProblemInfeasible]="ProblemInfeasible";
    status_[GroupsComposition]="GroupsComposition";
    status_[TooBig]="TooBig";
    status_[Timeout]="Timeout";
    status_[FDError]="FDError";
    status_[LocalInfeas]="LocalInfeas";
    status_[LicenseError]="LicenseError. Please set the WORHP_LICENSE_FILE environmental variable with the full path to the license file";
    status_[TerminatedByUser]="TerminatedByUser";
    status_[FunctionErrorF]="FunctionErrorF";
    status_[FunctionErrorG]="FunctionErrorG";
    status_[FunctionErrorDF]="FunctionErrorDF";
    status_[FunctionErrorDG]="FunctionErrorDG";
    status_[FunctionErrorHM]="FunctionErrorHM";
  }

  void WorhpInternal::reset(){

    // Number of (free) variables
    worhp_o_.n = nx_;

    // Number of constraints
    worhp_o_.m = ng_;

    // Free existing Worhp memory (except parameters)
    bool p_init_backup = worhp_p_.initialised; 
    worhp_p_.initialised = false; // Avoid freeing the memory for parameters
    if (worhp_o_.initialised || worhp_w_.initialised || worhp_c_.initialised){
      WorhpFree(&worhp_o_, &worhp_w_, &worhp_p_, &worhp_c_);
    }
    worhp_p_.initialised = p_init_backup; 
  
    /// Control data structure needs to be reset every time
    worhp_c_.initialised = false;
    worhp_w_.initialised = false;
    worhp_o_.initialised = false;
    
    // Worhp uses the CS format internally, hence it is the preferred sparse matrix format.  
    worhp_w_.DF.nnz = nx_;
    if (worhp_o_.m>0) {
      worhp_w_.DG.nnz = jacG_.output().size();  // Jacobian of G
    } else {
      worhp_w_.DG.nnz = 0;
    }

    if (exact_hessian_ /*worhp_w_.HM.NeedStructure*/) { // not initialized

      // Get the sparsity pattern of the Hessian
      const CRSSparsity& spHessLag = this->spHessLag();
      const vector<int>& rowind = spHessLag.rowind();
      const vector<int>& col = spHessLag.col();

      // Get number of nonzeros in the lower triangular part of the Hessian including full diagonal
      worhp_w_.HM.nnz = nx_; // diagonal entries
      for(int r=0; r<nx_; ++r){
        for(int el=rowind[r]; el<rowind[r+1] && col[el]<r; ++el){
          worhp_w_.HM.nnz++; // strictly lower triangular part
        }
      }
    } else {
      worhp_w_.HM.nnz = 0;
    }

    /* Data structure initialisation. */
    WorhpInit(&worhp_o_, &worhp_w_, &worhp_p_, &worhp_c_);
    if (worhp_c_.status != FirstCall) {
      casadi_error("Main: Initialisation failed. Status: " << formatStatus(worhp_c_.status));
    }

    if (worhp_w_.DF.NeedStructure){
      for(int i=0; i<nx_; ++i){
        worhp_w_.DF.row[i] = i + 1; // Index-1 based    
      }
    }
  
    if (worhp_o_.m>0 && worhp_w_.DG.NeedStructure) {    
      // Get sparsity pattern of the transpose since WORHP is column major
      int nz=0;
      const vector<int>& rowind = spJacG_T_.rowind();
      const vector<int>& col = spJacG_T_.col();
      for(int r=0; r<nx_; ++r){
        for(int el=rowind[r]; el<rowind[r+1]; ++el){
          int c = col[el];
          worhp_w_.DG.col[nz] = r + 1; // Index-1 based
          worhp_w_.DG.row[nz] = c + 1;
          nz++;
        }
      }
    }    

    if (worhp_w_.HM.NeedStructure) {
      // Get the sparsity pattern of the Hessian
      const CRSSparsity& spHessLag = this->spHessLag();
      const vector<int>& rowind = spHessLag.rowind();
      const vector<int>& col = spHessLag.col();

      int nz=0;
      
      // Upper triangular part of the Hessian (note CCS -> CRS format change)
      for(int r=0; r<nx_; ++r){
        for(int el=rowind[r]; el<rowind[r+1]; ++el){
          if(col[el]>r){
            worhp_w_.HM.row[nz] = col[el] + 1;
            worhp_w_.HM.col[nz] = r + 1;
            nz++;
          }
        }
      }
      
      // Diagonal always included
      for(int r=0; r<nx_; ++r){
        worhp_w_.HM.row[nz] = r + 1;
        worhp_w_.HM.col[nz] = r + 1;
        nz++;
      }
    }
  }

  void WorhpInternal::setQPOptions() {
    setOption("UserHM", true);
  }

  void WorhpInternal::passOptions() {

    /**
     *  Autogenerated from C_worhp_aux.h with params.pl
     *
     */
  
    if (hasSetOption("AcceptTolFeas")) worhp_p_.AcceptTolFeas = getOption("AcceptTolFeas");
    if (hasSetOption("AcceptTolOpti")) worhp_p_.AcceptTolOpti = getOption("AcceptTolOpti");
    if (hasSetOption("ArmijoBeta")) worhp_p_.ArmijoBeta = getOption("ArmijoBeta");
    if (hasSetOption("ArmijoMaxAlpha")) worhp_p_.ArmijoMaxAlpha = getOption("ArmijoMaxAlpha");
    if (hasSetOption("ArmijoMinAlpha")) worhp_p_.ArmijoMinAlpha = getOption("ArmijoMinAlpha");
    if (hasSetOption("ArmijoMinAlphaRec")) worhp_p_.ArmijoMinAlphaRec = getOption("ArmijoMinAlphaRec");
    if (hasSetOption("ArmijoSigma")) worhp_p_.ArmijoSigma = getOption("ArmijoSigma");
    if (hasSetOption("BettsFactor")) worhp_p_.BettsFactor = getOption("BettsFactor");
    if (hasSetOption("BettsPoint")) worhp_p_.BettsPoint = getOption("BettsPoint");
    if (hasSetOption("BoundTolFac")) worhp_p_.BoundTolFac = getOption("BoundTolFac");
    if (hasSetOption("CorStepBettsSum")) worhp_p_.CorStepBettsSum = getOption("CorStepBettsSum");
    if (hasSetOption("CorStepConvio")) worhp_p_.CorStepConvio = getOption("CorStepConvio");
    if (hasSetOption("CorStepConStop")) worhp_p_.CorStepConStop = getOption("CorStepConStop");
    if (hasSetOption("CorStepPFactor")) worhp_p_.CorStepPFactor = getOption("CorStepPFactor");
    if (hasSetOption("CorStepPMax")) worhp_p_.CorStepPMax = getOption("CorStepPMax");
    if (hasSetOption("CheckFJ")) worhp_p_.CheckFJ = getOption("CheckFJ");
    if (hasSetOption("CurvBCond")) worhp_p_.CurvBCond = getOption("CurvBCond");
    if (hasSetOption("CurvBFac")) worhp_p_.CurvBFac = getOption("CurvBFac");
    if (hasSetOption("CurvCond")) worhp_p_.CurvCond = getOption("CurvCond");
    if (hasSetOption("CurvFac")) worhp_p_.CurvFac = getOption("CurvFac");
    if (hasSetOption("CutLength")) worhp_p_.CutLength = getOption("CutLength");
    if (hasSetOption("FeasibleInitTol")) worhp_p_.FeasibleInitTol = getOption("FeasibleInitTol");
    if (hasSetOption("FidifEps")) worhp_p_.FidifEps = getOption("FidifEps");
    if (hasSetOption("FocusOnFeasFactor")) worhp_p_.FocusOnFeasFactor = getOption("FocusOnFeasFactor");
    if (hasSetOption("Infty")) worhp_p_.Infty = getOption("Infty");
    if (hasSetOption("InftyUnbounded")) worhp_p_.InftyUnbounded = getOption("InftyUnbounded");
    if (hasSetOption("LMestQPipComTol")) worhp_p_.LMestQPipComTol = getOption("LMestQPipComTol");
    if (hasSetOption("LMestQPipResTol")) worhp_p_.LMestQPipResTol = getOption("LMestQPipResTol");
    if (hasSetOption("LowPassAlphaF")) worhp_p_.LowPassAlphaF = getOption("LowPassAlphaF");
    if (hasSetOption("LowPassAlphaG")) worhp_p_.LowPassAlphaG = getOption("LowPassAlphaG");
    if (hasSetOption("LowPassAlphaMerit")) worhp_p_.LowPassAlphaMerit = getOption("LowPassAlphaMerit");
    if (hasSetOption("Ma57PivotThresh")) worhp_p_.Ma57PivotThresh = getOption("Ma57PivotThresh");
    if (hasSetOption("MeritGradTol")) worhp_p_.MeritGradTol = getOption("MeritGradTol");
    if (hasSetOption("PenUpdEpsKFac")) worhp_p_.PenUpdEpsKFac = getOption("PenUpdEpsKFac");
    if (hasSetOption("PenUpdEpsBar")) worhp_p_.PenUpdEpsBar = getOption("PenUpdEpsBar");
    if (hasSetOption("PenUpdMaxDeltaK")) worhp_p_.PenUpdMaxDeltaK = getOption("PenUpdMaxDeltaK");
    if (hasSetOption("PenUpdMaxFac")) worhp_p_.PenUpdMaxFac = getOption("PenUpdMaxFac");
    if (hasSetOption("PenUpdRBar")) worhp_p_.PenUpdRBar = getOption("PenUpdRBar");
    if (hasSetOption("PrecisionF")) worhp_p_.PrecisionF = getOption("PrecisionF");
    if (hasSetOption("PrecisionG")) worhp_p_.PrecisionG = getOption("PrecisionG");
    if (hasSetOption("QPscaleParam")) worhp_p_.QPscaleParam = getOption("QPscaleParam");
    if (hasSetOption("RelaxMaxDelta")) worhp_p_.RelaxMaxDelta = getOption("RelaxMaxDelta");
    if (hasSetOption("RelaxMaxPen")) worhp_p_.RelaxMaxPen = getOption("RelaxMaxPen");
    if (hasSetOption("RelaxRho")) worhp_p_.RelaxRho = getOption("RelaxRho");
    if (hasSetOption("RelaxStart")) worhp_p_.RelaxStart = getOption("RelaxStart");
    if (hasSetOption("ScaleFacObj")) worhp_p_.ScaleFacObj = getOption("ScaleFacObj");
    if (hasSetOption("ScaleFacQP")) worhp_p_.ScaleFacQP = getOption("ScaleFacQP");
    if (hasSetOption("StartBettsTau")) worhp_p_.StartBettsTau = getOption("StartBettsTau");
    if (hasSetOption("Timeout")) worhp_p_.Timeout = getOption("Timeout");
    if (hasSetOption("TolComp")) worhp_p_.TolComp = getOption("TolComp");
    if (hasSetOption("TolFeas")) worhp_p_.TolFeas = getOption("TolFeas");
    if (hasSetOption("TolOpti")) worhp_p_.TolOpti = getOption("TolOpti");
    if (hasSetOption("TolWeakActive")) worhp_p_.TolWeakActive = getOption("TolWeakActive");
    if (hasSetOption("TooBigCV")) worhp_p_.TooBigCV = getOption("TooBigCV");
    if (hasSetOption("TooBigKKT")) worhp_p_.TooBigKKT = getOption("TooBigKKT");
    if (hasSetOption("eps")) worhp_p_.eps = getOption("eps");
    if (hasSetOption("IncreaseIWS")) worhp_p_.IncreaseIWS = getOption("IncreaseIWS");
    if (hasSetOption("IncreaseRWS")) worhp_p_.IncreaseRWS = getOption("IncreaseRWS");
    if (hasSetOption("FilterGammaCV")) worhp_p_.FilterGammaCV = getOption("FilterGammaCV");
    if (hasSetOption("FilterGammaF")) worhp_p_.FilterGammaF = getOption("FilterGammaF");
    if (hasSetOption("GammaAlpha")) worhp_p_.GammaAlpha = getOption("GammaAlpha");
    if (hasSetOption("IncBettsTau")) worhp_p_.IncBettsTau = getOption("IncBettsTau");
    if (hasSetOption("IncBettsTauMore")) worhp_p_.IncBettsTauMore = getOption("IncBettsTauMore");
    if (hasSetOption("MinBettsTau")) worhp_p_.MinBettsTau = getOption("MinBettsTau");
    if (hasSetOption("ReduceBettsTau")) worhp_p_.ReduceBettsTau = getOption("ReduceBettsTau");
    if (hasSetOption("SwitchingDelta")) worhp_p_.SwitchingDelta = getOption("SwitchingDelta");
    if (hasSetOption("SwitchingSF")) worhp_p_.SwitchingSF = getOption("SwitchingSF");
    if (hasSetOption("SwitchingSCV")) worhp_p_.SwitchingSCV = getOption("SwitchingSCV");
    if (hasSetOption("BFGSmethod")) worhp_p_.BFGSmethod = getOption("BFGSmethod");
    if (hasSetOption("BFGSrestart")) worhp_p_.BFGSrestart = getOption("BFGSrestart");
    if (hasSetOption("BFGSmaxblockSize")) worhp_p_.BFGSmaxblockSize = getOption("BFGSmaxblockSize");
    if (hasSetOption("BFGSminblockSize")) worhp_p_.BFGSminblockSize = getOption("BFGSminblockSize");
    if (hasSetOption("CorStepMaxIter")) worhp_p_.CorStepMaxIter = getOption("CorStepMaxIter");
    if (hasSetOption("CorStepMethod")) worhp_p_.CorStepMethod = getOption("CorStepMethod");
    if (hasSetOption("CorStepMode")) worhp_p_.CorStepMode = getOption("CorStepMode");
    if (hasSetOption("GroupMethod")) worhp_p_.GroupMethod = getOption("GroupMethod");
    if (hasSetOption("LogLevel")) worhp_p_.LogLevel = getOption("LogLevel");
    if (hasSetOption("LogResult")) worhp_p_.LogResult = getOption("LogResult");
    if (hasSetOption("MaxCalls")) worhp_p_.MaxCalls = getOption("MaxCalls");
    if (hasSetOption("MaxForce")) worhp_p_.MaxForce = getOption("MaxForce");
    if (hasSetOption("MaxGPart")) worhp_p_.MaxGPart = getOption("MaxGPart");
    if (hasSetOption("MaxIter")) worhp_p_.MaxIter = getOption("MaxIter");
    if (hasSetOption("MeritFunction")) worhp_p_.MeritFunction = getOption("MeritFunction");
    if (hasSetOption("NLPmethod")) worhp_p_.NLPmethod = getOption("NLPmethod");
    if (hasSetOption("NLPprint")) worhp_p_.NLPprint = getOption("NLPprint");
    if (hasSetOption("PairMethod")) worhp_p_.PairMethod = getOption("PairMethod");
    if (hasSetOption("PenUpdEpsKSequence")) worhp_p_.PenUpdEpsKSequence = getOption("PenUpdEpsKSequence");
    if (hasSetOption("UserHMstructure")) worhp_p_.UserHMstructure = getOption("UserHMstructure");
    if (hasSetOption("MaxLScounter")) worhp_p_.MaxLScounter = getOption("MaxLScounter");
    if (hasSetOption("RegStrategy")) worhp_p_.RegStrategy = getOption("RegStrategy");
    if (hasSetOption("AutoQPRecovery")) worhp_p_.AutoQPRecovery = getOption("AutoQPRecovery");
    if (hasSetOption("CheckStructureDF")) worhp_p_.CheckStructureDF = getOption("CheckStructureDF");
    if (hasSetOption("CheckStructureDG")) worhp_p_.CheckStructureDG = getOption("CheckStructureDG");
    if (hasSetOption("CheckStructureHM")) worhp_p_.CheckStructureHM = getOption("CheckStructureHM");
    if (hasSetOption("CorStepRecoveryDX")) worhp_p_.CorStepRecoveryDX = getOption("CorStepRecoveryDX");
    if (hasSetOption("FGtogether")) worhp_p_.FGtogether = getOption("FGtogether");
    if (hasSetOption("FJandND")) worhp_p_.FJandND = getOption("FJandND");
    if (hasSetOption("FeasibleDual")) worhp_p_.FeasibleDual = getOption("FeasibleDual");
    if (hasSetOption("FeasibleInit")) worhp_p_.FeasibleInit = getOption("FeasibleInit");
    if (hasSetOption("FeasibleOnly")) worhp_p_.FeasibleOnly = getOption("FeasibleOnly");
    if (hasSetOption("FidifHM")) worhp_p_.FidifHM = getOption("FidifHM");
    if (hasSetOption("FirstDifCentral")) worhp_p_.FirstDifCentral = getOption("FirstDifCentral");
    if (hasSetOption("FocusOnFeas")) worhp_p_.FocusOnFeas = getOption("FocusOnFeas");
    if (hasSetOption("InitialLMest")) worhp_p_.InitialLMest = getOption("InitialLMest");
    if (hasSetOption("KeepAcceptableSol")) worhp_p_.KeepAcceptableSol = getOption("KeepAcceptableSol");
    if (hasSetOption("LinMult")) worhp_p_.LinMult = getOption("LinMult");
    if (hasSetOption("LowPassFilter")) worhp_p_.LowPassFilter = getOption("LowPassFilter");
    if (hasSetOption("MatrixCC")) worhp_p_.MatrixCC = getOption("MatrixCC");
    if (hasSetOption("MoreRelax")) worhp_p_.MoreRelax = getOption("MoreRelax");
    if (hasSetOption("QuadraticProblem")) worhp_p_.QuadraticProblem = getOption("QuadraticProblem");
    if (hasSetOption("RestUntilFeas")) worhp_p_.RestUntilFeas = getOption("RestUntilFeas");
    if (hasSetOption("ScaleConIter")) worhp_p_.ScaleConIter = getOption("ScaleConIter");
    if (hasSetOption("ScaledFD")) worhp_p_.ScaledFD = getOption("ScaledFD");
    if (hasSetOption("ScaledKKT")) worhp_p_.ScaledKKT = getOption("ScaledKKT");
    if (hasSetOption("ScaledObj")) worhp_p_.ScaledObj = getOption("ScaledObj");
    if (hasSetOption("ScaledQP")) worhp_p_.ScaledQP = getOption("ScaledQP");
    if (hasSetOption("TakeQPSol")) worhp_p_.TakeQPSol = getOption("TakeQPSol");
    if (hasSetOption("TooBig")) worhp_p_.TooBig = getOption("TooBig");
    if (hasSetOption("UserDF")) worhp_p_.UserDF = getOption("UserDF");
    if (hasSetOption("UserDG")) worhp_p_.UserDG = getOption("UserDG");
    if (hasSetOption("UserHM")) worhp_p_.UserHM = getOption("UserHM");
    if (hasSetOption("WeakActiveSet")) worhp_p_.WeakActiveSet = getOption("WeakActiveSet");
    if (hasSetOption("AlphaMinConst")) worhp_p_.AlphaMinConst = getOption("AlphaMinConst");
    if (hasSetOption("IgnoreFilterCrit")) worhp_p_.IgnoreFilterCrit = getOption("IgnoreFilterCrit");
    if (hasSetOption("FilterBisecAlpha")) worhp_p_.FilterBisecAlpha = getOption("FilterBisecAlpha");
    if (hasSetOption("FilterIntersecAlpha")) worhp_p_.FilterIntersecAlpha = getOption("FilterIntersecAlpha");
    if (hasSetOption("MaxNorm")) worhp_p_.MaxNorm = getOption("MaxNorm");
    if (hasSetOption("ReinitFilter")) worhp_p_.ReinitFilter = getOption("ReinitFilter");
    if (hasSetOption("DebugMarker06")) worhp_p_.DebugMarker06 = getOption("DebugMarker06");
    if (hasSetOption("initialised")) worhp_p_.initialised = getOption("initialised"); 
  
    if (hasSetOption("qp_ipBarrier")) worhp_p_.qp.ipBarrier = getOption("qp_ipBarrier");
    if (hasSetOption("qp_ipComTol")) worhp_p_.qp.ipComTol = getOption("qp_ipComTol");
    if (hasSetOption("qp_ipFracBound")) worhp_p_.qp.ipFracBound = getOption("qp_ipFracBound");
    if (hasSetOption("qp_ipLsMethod")) worhp_p_.qp.ipLsMethod = getOptionEnumValue("qp_ipLsMethod");
    if (hasSetOption("qp_ipMinAlpha")) worhp_p_.qp.ipMinAlpha = getOption("qp_ipMinAlpha");
    if (hasSetOption("qp_ipTryRelax")) worhp_p_.qp.ipTryRelax = getOption("qp_ipTryRelax");
    if (hasSetOption("qp_ipRelaxDiv")) worhp_p_.qp.ipRelaxDiv = getOption("qp_ipRelaxDiv");
    if (hasSetOption("qp_ipRelaxMult")) worhp_p_.qp.ipRelaxMult = getOption("qp_ipRelaxMult");
    if (hasSetOption("qp_ipRelaxMax")) worhp_p_.qp.ipRelaxMax = getOption("qp_ipRelaxMax");
    if (hasSetOption("qp_ipRelaxMin")) worhp_p_.qp.ipRelaxMin = getOption("qp_ipRelaxMin");
    if (hasSetOption("qp_ipResTol")) worhp_p_.qp.ipResTol = getOption("qp_ipResTol");
    if (hasSetOption("qp_lsItMaxIter")) worhp_p_.qp.lsItMaxIter = getOption("qp_lsItMaxIter");
    if (hasSetOption("qp_lsItMethod")) worhp_p_.qp.lsItMethod = getOptionEnumValue("qp_lsItMethod");
    if (hasSetOption("qp_lsItPrecondMethod")) worhp_p_.qp.lsItPrecondMethod = getOptionEnumValue("qp_lsItPrecondMethod");
    if (hasSetOption("qp_lsRefineMaxIter")) worhp_p_.qp.lsRefineMaxIter = getOption("qp_lsRefineMaxIter");
    if (hasSetOption("qp_lsScale")) worhp_p_.qp.lsScale = getOption("qp_lsScale");
    if (hasSetOption("qp_lsTrySimple")) worhp_p_.qp.lsTrySimple = getOption("qp_lsTrySimple");
    if (hasSetOption("qp_lsTol")) worhp_p_.qp.lsTol = getOption("qp_lsTol");
    if (hasSetOption("qp_maxIter")) worhp_p_.qp.maxIter = getOption("qp_maxIter");
    if (hasSetOption("qp_method")) worhp_p_.qp.method = getOptionEnumValue("qp_method");
    if (hasSetOption("qp_nsnBeta")) worhp_p_.qp.nsnBeta = getOption("qp_nsnBeta");
    if (hasSetOption("qp_nsnGradStep")) worhp_p_.qp.nsnGradStep = getOption("qp_nsnGradStep");
    if (hasSetOption("qp_nsnKKT")) worhp_p_.qp.nsnKKT = getOption("qp_nsnKKT");
    if (hasSetOption("qp_nsnLsMethod")) worhp_p_.qp.nsnLsMethod = getOptionEnumValue("qp_nsnLsMethod");
    if (hasSetOption("qp_nsnMinAlpha")) worhp_p_.qp.nsnMinAlpha = getOption("qp_nsnMinAlpha");
    if (hasSetOption("qp_nsnSigma")) worhp_p_.qp.nsnSigma = getOption("qp_nsnSigma");
    if (hasSetOption("qp_printLevel")) worhp_p_.qp.printLevel = getOptionEnumValue("qp_printLevel");
    if (hasSetOption("qp_scaleIntern")) worhp_p_.qp.scaleIntern = getOption("qp_scaleIntern");
    if (hasSetOption("qp_strict")) worhp_p_.qp.strict = getOption("qp_strict");  

    // Mark the parameters as set
    worhp_p_.initialised = true;
  }

  std::string WorhpInternal::formatStatus(int status) const {
    if (status_.find(status)==status_.end()) {
      std::stringstream ss;
      ss << "Unknown status: " << status;
      return ss.str();
    } else {
      return (*status_.find(status)).second;
    }
  }

  void WorhpInternal::evaluate(int nfdir, int nadir){
    log("WorhpInternal::evaluate");
    casadi_assert(nfdir==0 && nadir==0);
    
    // Prepare the solver
    reset();
    
    if (inputs_check_) checkInputs();
    checkInitialBounds();
  
    // Reset the counters
    t_eval_f_ = t_eval_grad_f_ = t_eval_g_ = t_eval_jac_g_ = t_eval_h_ = t_callback_fun_ = t_callback_prepare_ = t_mainloop_ = 0;
  
    // Get inputs
    log("WorhpInternal::evaluate: Reading user inputs");
    const DMatrix& x0 = input(NLP_SOLVER_X0);    
    const DMatrix& lbx = input(NLP_SOLVER_LBX);
    const DMatrix& ubx = input(NLP_SOLVER_UBX);
    const DMatrix& lam_x0 = input(NLP_SOLVER_LAM_X0);
    const DMatrix& lbg = input(NLP_SOLVER_LBG);
    const DMatrix& ubg = input(NLP_SOLVER_UBG);
    const DMatrix& lam_g0 = input(NLP_SOLVER_LAM_G0);

    double inf = numeric_limits<double>::infinity();  

    for (int i=0;i<nx_;++i) {
      casadi_assert_message(lbx.at(i)!=ubx.at(i),"WorhpSolver::evaluate: Worhp cannot handle the case when LBX == UBX. You have that case at non-zero " << i << " , which has value " << ubx.at(i) << ". Reformulate your problem by using a parameter for the corresponding variable.");
    }
  
    for (int i=0;i<lbg.size();++i) {
      casadi_assert_message(!(lbg.at(i)==-inf && ubg.at(i) == inf),"WorhpSolver::evaluate: Worhp cannot handle the case when both LBG and UBG are infinite. You have that case at non-zero " << i << ". Reformulate your problem eliminating the corresponding constraint.");
    }

    // Pass inputs to WORHP data structures
    x0.getArray(worhp_o_.X,worhp_o_.n);
    lbx.getArray(worhp_o_.XL,worhp_o_.n);
    ubx.getArray(worhp_o_.XU,worhp_o_.n);
    lam_x0.getArray(worhp_o_.Lambda,worhp_o_.n);
    if (worhp_o_.m>0){
      lam_g0.getArray(worhp_o_.Mu,worhp_o_.m);
      lbg.getArray(worhp_o_.GL,worhp_o_.m);
      ubg.getArray(worhp_o_.GU,worhp_o_.m);
    }

    // Replace infinite bounds with worhp_p_.Infty
    for(int i=0; i<nx_; ++i) if(worhp_o_.XL[i]==-inf) worhp_o_.XL[i] = -worhp_p_.Infty;
    for(int i=0; i<nx_; ++i) if(worhp_o_.XU[i]== inf) worhp_o_.XU[i] =  worhp_p_.Infty;
    for(int i=0; i<ng_; ++i) if(worhp_o_.GL[i]==-inf) worhp_o_.GL[i] = -worhp_p_.Infty;
    for(int i=0; i<ng_; ++i) if(worhp_o_.GU[i]== inf) worhp_o_.GU[i] =  worhp_p_.Infty;
  
    log("WorhpInternal::starting iteration");

    double time1 = clock();
  
    // Reverse Communication loop
    while(worhp_c_.status < TerminateSuccess &&  worhp_c_.status > TerminateError) {
      if (GetUserAction(&worhp_c_, callWorhp)) {
        Worhp(&worhp_o_, &worhp_w_, &worhp_p_, &worhp_c_);
      }

      if (GetUserAction(&worhp_c_, iterOutput)) {
        if (!callback_.isNull()) {
          double time1 = clock();
          // Copy outputs
          if (!output(NLP_SOLVER_X).empty())
            output(NLP_SOLVER_X).setArray(worhp_o_.X,worhp_o_.n);
          if (!output(NLP_SOLVER_F).empty())
            output(NLP_SOLVER_F).set(worhp_o_.F);
          if (!output(NLP_SOLVER_G).empty())
            output(NLP_SOLVER_G).setArray(worhp_o_.G,worhp_o_.m);
          if (!output(NLP_SOLVER_LAM_X).empty()) 
            output(NLP_SOLVER_LAM_X).setArray(worhp_o_.Lambda,worhp_o_.n);
          if (!output(NLP_SOLVER_LAM_G).empty())
            output(NLP_SOLVER_LAM_G).setArray(worhp_o_.Mu,worhp_o_.m);

          double time2 = clock();
          t_callback_prepare_ += double(time2-time1)/CLOCKS_PER_SEC;
          time1 = clock();
          callback_(ref_,user_data_);
          time2 = clock();
          t_callback_fun_ += double(time2-time1)/CLOCKS_PER_SEC;
        }
    
        IterationOutput(&worhp_o_, &worhp_w_, &worhp_p_, &worhp_c_);
        DoneUserAction(&worhp_c_, iterOutput);
      }

      if (GetUserAction(&worhp_c_, evalF)) {
        eval_f(worhp_o_.X, worhp_w_.ScaleObj, worhp_o_.F);
        DoneUserAction(&worhp_c_, evalF);
      }

      if (GetUserAction(&worhp_c_, evalG)) {
        eval_g(worhp_o_.X, worhp_o_.G);
        DoneUserAction(&worhp_c_, evalG);
      }

      if (GetUserAction(&worhp_c_, evalDF)) {
        eval_grad_f(worhp_o_.X, worhp_w_.ScaleObj, worhp_w_.DF.val);
        DoneUserAction(&worhp_c_, evalDF);
      }

      if (GetUserAction(&worhp_c_, evalDG)) {
        eval_jac_g(worhp_o_.X,worhp_w_.DG.val);
        DoneUserAction(&worhp_c_, evalDG);
      }

      if (GetUserAction(&worhp_c_, evalHM)) {
        eval_h(worhp_o_.X, worhp_w_.ScaleObj, worhp_o_.Mu, worhp_w_.HM.val);
        DoneUserAction(&worhp_c_, evalHM);
      }
    
      if (GetUserAction(&worhp_c_, fidif)) {
        WorhpFidif(&worhp_o_, &worhp_w_, &worhp_p_, &worhp_c_);
      }
    }

    double time2 = clock();
    t_mainloop_ += double(time2-time1)/CLOCKS_PER_SEC;
  
    // Copy outputs
    output(NLP_SOLVER_X).setArray(worhp_o_.X,worhp_o_.n,DENSE);
    output(NLP_SOLVER_F).set(worhp_o_.F);
    output(NLP_SOLVER_G).setArray(worhp_o_.G,worhp_o_.m,DENSE);
    output(NLP_SOLVER_LAM_X).setArray(worhp_o_.Lambda,worhp_o_.n);
    output(NLP_SOLVER_LAM_G).setArray(worhp_o_.Mu,worhp_o_.m,DENSE);
  
    StatusMsg(&worhp_o_, &worhp_w_, &worhp_p_, &worhp_c_);
 
    if (hasOption("print_time") && bool(getOption("print_time"))) {
      // Write timings
      cout << "time spent in eval_f: " << t_eval_f_ << " s." << endl;
      cout << "time spent in eval_grad_f: " << t_eval_grad_f_ << " s." << endl;
      cout << "time spent in eval_g: " << t_eval_g_ << " s." << endl;
      cout << "time spent in eval_jac_g: " << t_eval_jac_g_ << " s." << endl;
      cout << "time spent in eval_h: " << t_eval_h_ << " s." << endl;
      cout << "time spent in main loop: " << t_mainloop_ << " s." << endl;
      cout << "time spent in callback function: " << t_callback_fun_ << " s." << endl;
      cout << "time spent in callback preparation: " << t_callback_prepare_ << " s." << endl;
    }
  
    stats_["t_eval_f"] = t_eval_f_;
    stats_["t_eval_grad_f"] = t_eval_grad_f_;
    stats_["t_eval_g"] = t_eval_g_;
    stats_["t_eval_jac_g"] = t_eval_jac_g_;
    stats_["t_eval_h"] = t_eval_h_;
    stats_["t_mainloop"] = t_mainloop_;
    stats_["t_callback_fun"] = t_callback_fun_;
    stats_["t_callback_prepare"] = t_callback_prepare_;
    stats_["return_code"] = worhp_c_.status;
    stats_["return_status"] = flagmap[worhp_c_.status];
    
  }

  bool WorhpInternal::eval_h(const double* x, double obj_factor, const double* lambda, double* values){
    try{
      log("eval_h started");
      double time1 = clock();

      // Make sure generated
      casadi_assert_warning(!hessLag_.isNull(),"Hessian function not pregenerated");

      // Get Hessian 
      FX& hessLag = this->hessLag();

      // Pass input
      hessLag.setInput(x,HESSLAG_X);
      hessLag.setInput(input(NLP_SOLVER_P),HESSLAG_P);
      hessLag.setInput(obj_factor,HESSLAG_LAM_F);
      hessLag.setInput(lambda,HESSLAG_LAM_G);

      // Evaluate
      hessLag.evaluate();

      // Get results
      const DMatrix& H = hessLag.output();
      const vector<int>& rowind = H.rowind();
      const vector<int>& col = H.col();
      const vector<double>& data = H.data();

      // The Hessian values are divided into strictly upper (in WORHP lower) triangular and diagonal
      double* values_upper = values;
      double* values_diagonal = values + (worhp_w_.HM.nnz-nx_);

      // Initialize diagonal to zero
      for(int r=0; r<nx_; ++r){
        values_diagonal[r] = 0.;
      }

      // Upper triangular part of the Hessian (note CCS -> CRS format change)
      for(int r=0; r<nx_; ++r){
        for(int el=rowind[r]; el<rowind[r+1]; ++el){
          if(col[el]>r){
            // Strictly upper triangular
            *values_upper++ = data[el];
          } else if(col[el]==r){
            // Diagonal separartely
            values_diagonal[r] = data[el];
          }
        }
      }
      
      if(monitored("eval_h")){
        std::cout << "x = " <<  hessLag.input(HESSLAG_X) << std::endl;
        std::cout << "obj_factor= " << obj_factor << std::endl;
        std::cout << "lambda = " << hessLag.input(HESSLAG_LAM_G) << std::endl;
        std::cout << "H = " << hessLag.output(HESSLAG_HESS) << std::endl;
      }

      if (regularity_check_ && !isRegular(hessLag.output(HESSLAG_HESS).data())) casadi_error("WorhpInternal::eval_h: NaN or Inf detected.");
      
      double time2 = clock();
      t_eval_h_ += double(time2-time1)/CLOCKS_PER_SEC;
      log("eval_h ok");
      return true;
    } catch (exception& ex){
      cerr << "eval_h failed: " << ex.what() << endl;
      return false;
    }
  }

  bool WorhpInternal::eval_jac_g(const double* x,double* values){
    try{
      log("eval_jac_g started");
    
      // Quich finish if no constraints
      if(worhp_o_.m==0){
        log("eval_jac_g quick return (m==0)");
        return true;
      }
   
      // Make sure generated
      casadi_assert(!jacG_.isNull());
 
      // Get Jacobian
      FX& jacG = this->jacG();

      double time1 = clock();

      // Pass the argument to the function
      jacG.setInput(x,JACG_X);
      jacG.setInput(input(NLP_SOLVER_P),JACG_P);
    
      // Evaluate the function
      jacG.evaluate();

      // Transpose the result
      const DMatrix& J = jacG.output(JACG_JAC);
      const vector<double>& J_data = J.data();
      const vector<int>& J_rowind = J.rowind();
      const vector<int>& JT_col = spJacG_T_.col();
      copy(J_rowind.begin(),J_rowind.end(),jacG_tmp_.begin());
      for(vector<int>::const_iterator i=JT_col.begin(); i!=JT_col.end(); ++i){
        *values++ = J_data[jacG_tmp_[*i]++];
      }
    
      if(monitored("eval_jac_g")){
        cout << "x = " << jacG_.input().data() << endl;
        cout << "J = " << endl;
        jacG_.output().printSparse();
      }
    
      double time2 = clock();
      t_eval_jac_g_ += double(time2-time1)/CLOCKS_PER_SEC;
    
      log("eval_jac_g ok");
      return true;
    } catch (exception& ex){
      cerr << "eval_jac_g failed: " << ex.what() << endl;
      return false;
    }
  }

  bool WorhpInternal::eval_f(const double* x, double scale, double& obj_value){
    try {
      log("eval_f started");
    
      // Log time
      double time1 = clock();

      // Pass the argument to the function
      nlp_.setInput(x, NL_X);
      nlp_.setInput(input(NLP_SOLVER_P),NL_P);
      
      // Evaluate the function
      nlp_.evaluate();

      // Get the result
      nlp_.getOutput(obj_value,NL_F);

      // Printing
      if(monitored("eval_f")){
        cout << "x = " << nlp_.input(NL_X) << endl;
        cout << "obj_value = " << obj_value << endl;
      }
      obj_value *= scale;

      if (regularity_check_ && !isRegular(nlp_.output().data())) casadi_error("WorhpInternal::eval_f: NaN or Inf detected.");

      double time2 = clock();
      t_eval_f_ += double(time2-time1)/CLOCKS_PER_SEC;

      log("eval_f ok");
      return true;
    } catch (exception& ex){
      cerr << "eval_f failed: " << ex.what() << endl;
      return false;
    }
  }

  bool WorhpInternal::eval_g(const double* x, double* g)
  {
    try {
      log("eval_g started");
      double time1 = clock();

      if(worhp_o_.m>0){
        // Pass the argument to the function
        nlp_.setInput(x,NL_X);
        nlp_.setInput(input(NLP_SOLVER_P),NL_P);

        // Evaluate the function and tape
        nlp_.evaluate();

        // Ge the result
        nlp_.getOutput(g,NL_G);

        // Printing
        if(monitored("eval_g")){
          cout << "x = " << nlp_.input(NL_X) << endl;
          cout << "g = " << nlp_.output(NL_G) << endl;
        }
      }

      if (regularity_check_ && !isRegular(nlp_.output(NL_G).data())) casadi_error("WorhpInternal::eval_g: NaN or Inf detected.");
    
      double time2 = clock();
      t_eval_g_ += double(time2-time1)/CLOCKS_PER_SEC;
    
      log("eval_g ok");
      return true;
    } catch (exception& ex){
      cerr << "eval_g failed: " << ex.what() << endl;
      return false;
    }
  }

  bool WorhpInternal::eval_grad_f(const double* x, double scale , double* grad_f )
  {
    try {
      log("eval_grad_f started");
      double time1 = clock();
    
      // Pass the argument to the function
      gradF_.setInput(x,NL_X);
      gradF_.setInput(input(NLP_SOLVER_P),NL_P);
      
      // Evaluate, adjoint mode
      gradF_.evaluate();
      
      // Get the result
      gradF_.output().get(grad_f,DENSE);

      // Scale
      for(int i=0; i<nx_; ++i){
        grad_f[i] *= scale;
      }
      
      // Printing
      if(monitored("eval_grad_f")){
        cout << "grad_f = " << gradF_.output() << endl;
      }
      
      if (regularity_check_ && !isRegular(gradF_.output().data())) casadi_error("WorhpInternal::eval_grad_f: NaN or Inf detected.");
    
      double time2 = clock();
      t_eval_grad_f_ += double(time2-time1)/CLOCKS_PER_SEC;

      // Check the result for regularity
      for(int i=0; i<nx_; ++i){
        if(isnan(grad_f[i]) || isinf(grad_f[i])){
          log("eval_grad_f: result not regular");
          return false;
        }
      }

      log("eval_grad_f ok");
      return true;
    } catch (exception& ex){
      cerr << "eval_jac_f failed: " << ex.what() << endl;
      return false;
    }
  }

  void WorhpInternal::setOptionsFromFile(const std::string & file) {
    int status;
    char *cpy = new char[file.size()+1] ;
    strcpy(cpy, file.c_str());
    worhp_p_.initialised = true;
    ReadParamsNoInit(&status, cpy, &worhp_p_);
    delete cpy;
    setOption("AcceptTolFeas",worhp_p_.AcceptTolFeas);
    setOption("AcceptTolOpti",worhp_p_.AcceptTolOpti);
    setOption("ArmijoBeta",worhp_p_.ArmijoBeta);
    setOption("ArmijoMaxAlpha",worhp_p_.ArmijoMaxAlpha);
    setOption("ArmijoMinAlpha",worhp_p_.ArmijoMinAlpha);
    setOption("ArmijoMinAlphaRec",worhp_p_.ArmijoMinAlphaRec);
    setOption("ArmijoSigma",worhp_p_.ArmijoSigma);
    setOption("BettsFactor",worhp_p_.BettsFactor);
    setOption("BettsPoint",worhp_p_.BettsPoint);
    setOption("BoundTolFac",worhp_p_.BoundTolFac);
    setOption("CorStepBettsSum",worhp_p_.CorStepBettsSum);
    setOption("CorStepConvio",worhp_p_.CorStepConvio);
    setOption("CorStepConStop",worhp_p_.CorStepConStop);
    setOption("CorStepPFactor",worhp_p_.CorStepPFactor);
    setOption("CorStepPMax",worhp_p_.CorStepPMax);
    setOption("CheckFJ",worhp_p_.CheckFJ);
    setOption("CurvBCond",worhp_p_.CurvBCond);
    setOption("CurvBFac",worhp_p_.CurvBFac);
    setOption("CurvCond",worhp_p_.CurvCond);
    setOption("CurvFac",worhp_p_.CurvFac);
    setOption("CutLength",worhp_p_.CutLength);
    setOption("FeasibleInitTol",worhp_p_.FeasibleInitTol);
    setOption("FidifEps",worhp_p_.FidifEps);
    setOption("FocusOnFeasFactor",worhp_p_.FocusOnFeasFactor);
    setOption("Infty",worhp_p_.Infty);
    setOption("InftyUnbounded",worhp_p_.InftyUnbounded);
    setOption("LMestQPipComTol",worhp_p_.LMestQPipComTol);
    setOption("LMestQPipResTol",worhp_p_.LMestQPipResTol);
    setOption("LowPassAlphaF",worhp_p_.LowPassAlphaF);
    setOption("LowPassAlphaG",worhp_p_.LowPassAlphaG);
    setOption("LowPassAlphaMerit",worhp_p_.LowPassAlphaMerit);
    setOption("Ma57PivotThresh",worhp_p_.Ma57PivotThresh);
    setOption("MeritGradTol",worhp_p_.MeritGradTol);
    setOption("PenUpdEpsKFac",worhp_p_.PenUpdEpsKFac);
    setOption("PenUpdEpsBar",worhp_p_.PenUpdEpsBar);
    setOption("PenUpdMaxDeltaK",worhp_p_.PenUpdMaxDeltaK);
    setOption("PenUpdMaxFac",worhp_p_.PenUpdMaxFac);
    setOption("PenUpdRBar",worhp_p_.PenUpdRBar);
    setOption("PrecisionF",worhp_p_.PrecisionF);
    setOption("PrecisionG",worhp_p_.PrecisionG);
    setOption("QPscaleParam",worhp_p_.QPscaleParam);
    setOption("RelaxMaxDelta",worhp_p_.RelaxMaxDelta);
    setOption("RelaxMaxPen",worhp_p_.RelaxMaxPen);
    setOption("RelaxRho",worhp_p_.RelaxRho);
    setOption("RelaxStart",worhp_p_.RelaxStart);
    setOption("ScaleFacObj",worhp_p_.ScaleFacObj);
    setOption("ScaleFacQP",worhp_p_.ScaleFacQP);
    setOption("StartBettsTau",worhp_p_.StartBettsTau);
    setOption("Timeout",worhp_p_.Timeout);
    setOption("TolComp",worhp_p_.TolComp);
    setOption("TolFeas",worhp_p_.TolFeas);
    setOption("TolOpti",worhp_p_.TolOpti);
    setOption("TolWeakActive",worhp_p_.TolWeakActive);
    setOption("TooBigCV",worhp_p_.TooBigCV);
    setOption("TooBigKKT",worhp_p_.TooBigKKT);
    setOption("eps",worhp_p_.eps);
    setOption("IncreaseIWS",worhp_p_.IncreaseIWS);
    setOption("IncreaseRWS",worhp_p_.IncreaseRWS);
    setOption("FilterGammaCV",worhp_p_.FilterGammaCV);
    setOption("FilterGammaF",worhp_p_.FilterGammaF);
    setOption("GammaAlpha",worhp_p_.GammaAlpha);
    setOption("IncBettsTau",worhp_p_.IncBettsTau);
    setOption("IncBettsTauMore",worhp_p_.IncBettsTauMore);
    setOption("MinBettsTau",worhp_p_.MinBettsTau);
    setOption("ReduceBettsTau",worhp_p_.ReduceBettsTau);
    setOption("SwitchingDelta",worhp_p_.SwitchingDelta);
    setOption("SwitchingSF",worhp_p_.SwitchingSF);
    setOption("SwitchingSCV",worhp_p_.SwitchingSCV);
    setOption("BFGSmethod",worhp_p_.BFGSmethod);
    setOption("BFGSrestart",worhp_p_.BFGSrestart);
    setOption("BFGSmaxblockSize",worhp_p_.BFGSmaxblockSize);
    setOption("BFGSminblockSize",worhp_p_.BFGSminblockSize);
    setOption("CorStepMaxIter",worhp_p_.CorStepMaxIter);
    setOption("CorStepMethod",worhp_p_.CorStepMethod);
    setOption("CorStepMode",worhp_p_.CorStepMode);
    setOption("GroupMethod",worhp_p_.GroupMethod);
    setOption("LogLevel",worhp_p_.LogLevel);
    setOption("LogResult",worhp_p_.LogResult);
    setOption("MaxCalls",worhp_p_.MaxCalls);
    setOption("MaxForce",worhp_p_.MaxForce);
    setOption("MaxGPart",worhp_p_.MaxGPart);
    setOption("MaxIter",worhp_p_.MaxIter);
    setOption("MeritFunction",worhp_p_.MeritFunction);
    setOption("NLPmethod",worhp_p_.NLPmethod);
    setOption("NLPprint",worhp_p_.NLPprint);
    setOption("PairMethod",worhp_p_.PairMethod);
    setOption("PenUpdEpsKSequence",worhp_p_.PenUpdEpsKSequence);
    setOption("UserHMstructure",worhp_p_.UserHMstructure);
    setOption("MaxLScounter",worhp_p_.MaxLScounter);
    setOption("RegStrategy",worhp_p_.RegStrategy);
    setOption("AutoQPRecovery",worhp_p_.AutoQPRecovery);
    setOption("CheckStructureDF",worhp_p_.CheckStructureDF);
    setOption("CheckStructureDG",worhp_p_.CheckStructureDG);
    setOption("CheckStructureHM",worhp_p_.CheckStructureHM);
    setOption("CorStepRecoveryDX",worhp_p_.CorStepRecoveryDX);
    setOption("FGtogether",worhp_p_.FGtogether);
    setOption("FJandND",worhp_p_.FJandND);
    setOption("FeasibleDual",worhp_p_.FeasibleDual);
    setOption("FeasibleInit",worhp_p_.FeasibleInit);
    setOption("FeasibleOnly",worhp_p_.FeasibleOnly);
    setOption("FidifHM",worhp_p_.FidifHM);
    setOption("FirstDifCentral",worhp_p_.FirstDifCentral);
    setOption("FocusOnFeas",worhp_p_.FocusOnFeas);
    setOption("InitialLMest",worhp_p_.InitialLMest);
    setOption("KeepAcceptableSol",worhp_p_.KeepAcceptableSol);
    setOption("LinMult",worhp_p_.LinMult);
    setOption("LowPassFilter",worhp_p_.LowPassFilter);
    setOption("MatrixCC",worhp_p_.MatrixCC);
    setOption("MoreRelax",worhp_p_.MoreRelax);
    setOption("QuadraticProblem",worhp_p_.QuadraticProblem);
    setOption("RestUntilFeas",worhp_p_.RestUntilFeas);
    setOption("ScaleConIter",worhp_p_.ScaleConIter);
    setOption("ScaledFD",worhp_p_.ScaledFD);
    setOption("ScaledKKT",worhp_p_.ScaledKKT);
    setOption("ScaledObj",worhp_p_.ScaledObj);
    setOption("ScaledQP",worhp_p_.ScaledQP);
    setOption("TakeQPSol",worhp_p_.TakeQPSol);
    setOption("TooBig",worhp_p_.TooBig);
    setOption("UserDF",worhp_p_.UserDF);
    setOption("UserDG",worhp_p_.UserDG);
    setOption("UserHM",worhp_p_.UserHM);
    setOption("WeakActiveSet",worhp_p_.WeakActiveSet);
    setOption("AlphaMinConst",worhp_p_.AlphaMinConst);
    setOption("IgnoreFilterCrit",worhp_p_.IgnoreFilterCrit);
    setOption("FilterBisecAlpha",worhp_p_.FilterBisecAlpha);
    setOption("FilterIntersecAlpha",worhp_p_.FilterIntersecAlpha);
    setOption("MaxNorm",worhp_p_.MaxNorm);
    setOption("ReinitFilter",worhp_p_.ReinitFilter);
    setOption("DebugMarker06",worhp_p_.DebugMarker06);
    setOption("initialised",worhp_p_.initialised);
    
    setOption("qp_ipBarrier",worhp_p_.qp.ipBarrier);
    setOption("qp_ipComTol",worhp_p_.qp.ipComTol);
    setOption("qp_ipFracBound",worhp_p_.qp.ipFracBound);
    setOptionByEnumValue("qp_ipLsMethod",worhp_p_.qp.ipLsMethod );
    setOption("qp_ipMinAlpha",worhp_p_.qp.ipMinAlpha);
    setOption("qp_ipTryRelax",worhp_p_.qp.ipTryRelax);
    setOption("qp_ipRelaxDiv",worhp_p_.qp.ipRelaxDiv);
    setOption("qp_ipRelaxMult",worhp_p_.qp.ipRelaxMult);
    setOption("qp_ipRelaxMax",worhp_p_.qp.ipRelaxMax);
    setOption("qp_ipRelaxMin",worhp_p_.qp.ipRelaxMin);
    setOption("qp_ipResTol",worhp_p_.qp.ipResTol);
    setOption("qp_lsItMaxIter",worhp_p_.qp.lsItMaxIter);
    setOptionByEnumValue("qp_lsItMethod",worhp_p_.qp.lsItMethod );
    setOptionByEnumValue("qp_lsItPrecondMethod",worhp_p_.qp.lsItPrecondMethod );
    setOption("qp_lsRefineMaxIter",worhp_p_.qp.lsRefineMaxIter);
    setOption("qp_lsScale",worhp_p_.qp.lsScale);
    setOption("qp_lsTrySimple",worhp_p_.qp.lsTrySimple);
    setOption("qp_lsTol",worhp_p_.qp.lsTol);
    setOption("qp_maxIter",worhp_p_.qp.maxIter);
    setOptionByEnumValue("qp_method",worhp_p_.qp.method );
    setOption("qp_nsnBeta",worhp_p_.qp.nsnBeta);
    setOption("qp_nsnGradStep",worhp_p_.qp.nsnGradStep);
    setOption("qp_nsnKKT",worhp_p_.qp.nsnKKT);
    setOptionByEnumValue("qp_nsnLsMethod",worhp_p_.qp.nsnLsMethod );
    setOption("qp_nsnMinAlpha",worhp_p_.qp.nsnMinAlpha);
    setOption("qp_nsnSigma",worhp_p_.qp.nsnSigma);
    setOptionByEnumValue("qp_printLevel",worhp_p_.qp.printLevel );
    setOption("qp_scaleIntern",worhp_p_.qp.scaleIntern);
    setOption("qp_strict",worhp_p_.qp.strict);
      
    std::cout << "readparams status: " << status << std::endl;
  }
  
  map<int,string> WorhpInternal::calc_flagmap(){
  map<int,string> f;
  f[TerminateSuccess] = "TerminateSuccess";
  f[OptimalSolution] = "OptimalSolution";
  f[SearchDirectionZero] = "SearchDirectionZero";
  f[SearchDirectionSmall] = "SearchDirectionSmall";
  f[StationaryPointFound] = "StationaryPointFound";
  f[StationaryPointFound] = "StationaryPointFound";
  f[AcceptablePrevious] = "AcceptablePrevious";
  f[FritzJohn] = "FritzJohn";
  f[NotDiffable] = "NotDiffable";
  f[Unbounded] = "Unbounded";
  f[FeasibleSolution] = "FeasibleSolution";
  f[LowPassFilterOptimal] = "LowPassFilterOptimal";
  f[LowPassFilterAcceptable] = "LowPassFilterAcceptable";

  f[TerminateError] = "TerminateError";
  f[InitError] = "InitError";
  f[DataError] = "DataError";
  f[MaxCalls] = "MaxCalls";
  f[MaxIter] = "MaxIter";
  f[MinimumStepsize] = "MinimumStepsize";
  f[QPerror] = "QPerror";
  f[ProblemInfeasible] = "ProblemInfeasible";
  f[GroupsComposition] = "GroupsComposition";
  f[TooBig] = "TooBig";
  f[Timeout] = "Timeout";
  f[FDError] = "FDError";
  f[LocalInfeas] = "LocalInfeas";
  f[LicenseError] = "LicenseError";
  f[TerminatedByUser] = "TerminatedByUser";
  f[FunctionErrorF] = "FunctionErrorF";
  f[FunctionErrorG] = "FunctionErrorG";
  f[FunctionErrorDF] = "FunctionErrorDF";
  f[FunctionErrorDG] = "FunctionErrorDG";
  f[FunctionErrorHM] = "FunctionErrorHM";
  return f;
}
  
map<int,string> WorhpInternal::flagmap = WorhpInternal::calc_flagmap();



} // namespace CasADi

