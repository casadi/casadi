/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010 by Joel Andersson, Moritz Diehl, K.U.Leuven. All rights reserved.
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

#include "worhp_internal.hpp"
#include "symbolic/stl_vector_tools.hpp"
#include "symbolic/matrix/matrix_tools.hpp"
#include "symbolic/mx/mx_tools.hpp"
#include "symbolic/matrix/sparsity_tools.hpp"
#include "symbolic/fx/mx_function.hpp"
#include <ctime>

using namespace std;

namespace CasADi{

  WorhpInternal::WorhpInternal(const FX& nlp) : NLPSolverInternal(nlp){

    // Monitors
    addOption("monitor",      OT_STRINGVECTOR, GenericType(),  "", "eval_f|eval_g|eval_jac_g|eval_grad_f|eval_h", true);
    addOption("print_time",               OT_BOOLEAN, true, "print information about execution time");
  
    int status;
    InitParams(&status, &worhp_p);
  
    std::stringstream ss;
    ss << "Armijo recovery strategies. Vector of size " << NAres;
  
    std::vector<int> ares(NAres);
    std::copy(worhp_p.Ares,worhp_p.Ares+NAres,ares.begin());
    addOption("Ares",OT_INTEGERVECTOR,ares,ss.str());
    
    // Overwriting defaults
    worhp_p.UserHM = false;
  
    /**
     *  Autogenerated from C_worhp_aux.h with params.pl
     *
     */
  
    addOption("AcceptTolFeas",OT_REAL,worhp_p.AcceptTolFeas,"Tolerance for acceptable feasibility");
    addOption("AcceptTolOpti",OT_REAL,worhp_p.AcceptTolOpti,"Tolerance for acceptable optimality");
    addOption("ArmijoBeta",OT_REAL,worhp_p.ArmijoBeta,"Trial stepsize decrease factor for Armijo rule");
    addOption("ArmijoMaxAlpha",OT_REAL,worhp_p.ArmijoMaxAlpha,"Initial alpha for Armijo rule");
    addOption("ArmijoMinAlpha",OT_REAL,worhp_p.ArmijoMinAlpha,"Lower bound on alpha for Armijo rule");
    addOption("ArmijoMinAlphaRec",OT_REAL,worhp_p.ArmijoMinAlphaRec,"Lower bound on alpha for Armijo rule during recovery");
    addOption("ArmijoSigma",OT_REAL,worhp_p.ArmijoSigma,"Scale factor for linearised descent check in Armijo rule");
    addOption("BettsFactor",OT_REAL,worhp_p.BettsFactor,"Update factor for Betts' Hessian regularisation");
    addOption("BettsPoint",OT_REAL,worhp_p.BettsPoint,"Smallest eigenvalue of the regularised Hessian");
    addOption("BoundTolFac",OT_REAL,worhp_p.BoundTolFac,"Factor in determining active constraints by KKT");
    addOption("CorStepBettsSum",OT_REAL,worhp_p.CorStepBettsSum,"(experimental)");
    addOption("CorStepConvio",OT_REAL,worhp_p.CorStepConvio,"(experimental)");
    addOption("CorStepConStop",OT_REAL,worhp_p.CorStepConStop,"(experimental)");
    addOption("CorStepPFactor",OT_REAL,worhp_p.CorStepPFactor,"(experimental)");
    addOption("CorStepPMax",OT_REAL,worhp_p.CorStepPMax,"(experimental)");
    addOption("CheckFJ",OT_REAL,worhp_p.CheckFJ,"Upper bound used by Fritz-John heuristic");
    addOption("CurvBCond",OT_REAL,worhp_p.CurvBCond,"Block BFGS curvature condition bound");
    addOption("CurvBFac",OT_REAL,worhp_p.CurvBFac,"Block BFGS curvature condition regularisation factor");
    addOption("CurvCond",OT_REAL,worhp_p.CurvCond,"BFGS Curvature condition bound");
    addOption("CurvFac",OT_REAL,worhp_p.CurvFac,"BFGS curvature condition regularisation factor");
    addOption("CutLength",OT_REAL,worhp_p.CutLength,"Scaling factor for Cut recovery strategy");
    addOption("FeasibleInitTol",OT_REAL,worhp_p.FeasibleInitTol,"Feasibility tolerance for no-objective feasible mode");
    addOption("FidifEps",OT_REAL,worhp_p.FidifEps,"Finite difference perturbation");
    addOption("FocusOnFeasFactor",OT_REAL,worhp_p.FocusOnFeasFactor,"Factor in Focus-on-Feasibility mode");
    addOption("Infty",OT_REAL,worhp_p.Infty,"Upper bound for numbers to be regarded as finite");
    addOption("InftyUnbounded",OT_REAL,worhp_p.InftyUnbounded,"Tolerance for unboundedness detection heuristic");
    addOption("LMestQPipComTol",OT_REAL,worhp_p.LMestQPipComTol,"IP complementarity tolerance in initial multiplier estimate");
    addOption("LMestQPipResTol",OT_REAL,worhp_p.LMestQPipResTol,"IP residual tolerance in initial multiplier estimate");
    addOption("LowPassAlphaF",OT_REAL,worhp_p.LowPassAlphaF,"Lowpass-filter update factor for objective values");
    addOption("LowPassAlphaG",OT_REAL,worhp_p.LowPassAlphaG,"Lowpass-filter update factor for constraint values");
    addOption("LowPassAlphaMerit",OT_REAL,worhp_p.LowPassAlphaMerit,"Lowpass-filter update factor for merit function values");
    addOption("Ma57PivotThresh",OT_REAL,worhp_p.Ma57PivotThresh,"Pivoting tolerance for MA57 = CNTL(1)");
    addOption("MeritGradTol",OT_REAL,worhp_p.MeritGradTol,"Threshold of meritfunction gradient for increasing Hessian regularisation");
    addOption("PenUpdEpsKFac",OT_REAL,worhp_p.PenUpdEpsKFac,"Penalty update parameter factor for MeritFunction = 4");
    addOption("PenUpdEpsBar",OT_REAL,worhp_p.PenUpdEpsBar,"Penalty update parameter factor for MeritFunction = 3");
    addOption("PenUpdMaxDeltaK",OT_REAL,worhp_p.PenUpdMaxDeltaK,"Max penalty for MeritFunction = 4");
    addOption("PenUpdMaxFac",OT_REAL,worhp_p.PenUpdMaxFac,"Max factor for increasing penalty for MeritFunction = 4");
    addOption("PenUpdRBar",OT_REAL,worhp_p.PenUpdRBar,"Penalty update parameter for MeritFunction = 3");
    addOption("PrecisionF",OT_REAL,worhp_p.PrecisionF,"(currently unused) Relative precision of objective");
    addOption("PrecisionG",OT_REAL,worhp_p.PrecisionG,"(currently unused) Relative precision of constraints");
    addOption("QPscaleParam",OT_REAL,worhp_p.QPscaleParam,"(currently unused)");
    addOption("RelaxMaxDelta",OT_REAL,worhp_p.RelaxMaxDelta,"Upper bound for accepting the constraint relaxation variable");
    addOption("RelaxMaxPen",OT_REAL,worhp_p.RelaxMaxPen,"Upper bound on the constraint relaxation penalty");
    addOption("RelaxRho",OT_REAL,worhp_p.RelaxRho,"Update factor for the constraint relaxation penalty");
    addOption("RelaxStart",OT_REAL,worhp_p.RelaxStart,"Initial value of the constraint relaxation penalty");
    addOption("ScaleFacObj",OT_REAL,worhp_p.ScaleFacObj,"Value to scale large objective functions to");
    addOption("ScaleFacQP",OT_REAL,worhp_p.ScaleFacQP,"Upper bound on resulting matrix norm for QP scaling");
    addOption("StartBettsTau",OT_REAL,worhp_p.StartBettsTau,"Initial value for Betts' update dampening term");
    addOption("Timeout",OT_REAL,worhp_p.Timeout,"Timeout in seconds");
    addOption("TolComp",OT_REAL,worhp_p.TolComp,"Complementarity tolerance");
    addOption("TolFeas",OT_REAL,worhp_p.TolFeas,"Feasibility tolerance");
    addOption("TolOpti",OT_REAL,worhp_p.TolOpti,"Optimality tolerance");
    addOption("TolWeakActive",OT_REAL,worhp_p.TolWeakActive,"(experimental)");
    addOption("TooBigCV",OT_REAL,worhp_p.TooBigCV,"Upper bound on constraint violation for too-big heuristic");
    addOption("TooBigKKT",OT_REAL,worhp_p.TooBigKKT,"Upper bound on KKT values for too-big heuristic");
    addOption("eps",OT_REAL,worhp_p.eps,"Machine epsilon");
    addOption("IncreaseIWS",OT_REAL,worhp_p.IncreaseIWS,"Increase factor for estimated integer workspace requirement");
    addOption("IncreaseRWS",OT_REAL,worhp_p.IncreaseRWS,"Increase factor for estimated real workspace requirement");
    addOption("FilterGammaCV",OT_REAL,worhp_p.FilterGammaCV,"Constraint violation decrease factor in Filter acceptance check");
    addOption("FilterGammaF",OT_REAL,worhp_p.FilterGammaF,"Objective decrease factor in Filter acceptance check");
    addOption("GammaAlpha",OT_REAL,worhp_p.GammaAlpha,"Safety factor for alphamin calculation by Filter");
    addOption("IncBettsTau",OT_REAL,worhp_p.IncBettsTau,"Increase factor for Betts' update dampening term");
    addOption("IncBettsTauMore",OT_REAL,worhp_p.IncBettsTauMore,"Larger increase factor for Betts' update dampening term");
    addOption("MinBettsTau",OT_REAL,worhp_p.MinBettsTau,"Lower bound for Betts' update dampening term");
    addOption("ReduceBettsTau",OT_REAL,worhp_p.ReduceBettsTau,"Decrease factor for Betts' update dampening term");
    addOption("SwitchingDelta",OT_REAL,worhp_p.SwitchingDelta,"Filter switching condition parameter");
    addOption("SwitchingSF",OT_REAL,worhp_p.SwitchingSF,"Filter switching condition parameter");
    addOption("SwitchingSCV",OT_REAL,worhp_p.SwitchingSCV,"Filter switching condition parameter");
    addOption("BFGSmethod",OT_INTEGER,worhp_p.BFGSmethod,"Choose BFGS method (dense, block, sparse)");
    addOption("BFGSrestart",OT_INTEGER,worhp_p.BFGSrestart,"Restart BFGS update after this many iterations");
    addOption("BFGSmaxblockSize",OT_INTEGER,worhp_p.BFGSmaxblockSize,"Maximum BFGS block size (depends on BFGS method)");
    addOption("BFGSminblockSize",OT_INTEGER,worhp_p.BFGSminblockSize,"Minimum BFGS block size (depends on BFGS method)");
    addOption("CorStepMaxIter",OT_INTEGER,worhp_p.CorStepMaxIter,"(experimental)");
    addOption("CorStepMethod",OT_INTEGER,worhp_p.CorStepMethod,"(experimental)");
    addOption("CorStepMode",OT_INTEGER,worhp_p.CorStepMode,"(experimental)");
    addOption("GroupMethod",OT_INTEGER,worhp_p.GroupMethod,"Select method to determine graph colouring groups");
    addOption("LogLevel",OT_INTEGER,worhp_p.LogLevel,"Enable XML logfiles and writing interval");
    addOption("LogResult",OT_INTEGER,worhp_p.LogResult,"Enable XML result logging and detail level");
    addOption("MaxCalls",OT_INTEGER,worhp_p.MaxCalls,"Upper bound to Reverse Communication calls");
    addOption("MaxForce",OT_INTEGER,worhp_p.MaxForce,"Maximum number of Force recovery strategy steps");
    addOption("MaxGPart",OT_INTEGER,worhp_p.MaxGPart,"(experimental)");
    addOption("MaxIter",OT_INTEGER,worhp_p.MaxIter,"Upper bound on major iterations");
    addOption("MeritFunction",OT_INTEGER,worhp_p.MeritFunction,"Select merit function and penalty update [0, 3..5]");
    addOption("NLPmethod",OT_INTEGER,worhp_p.NLPmethod,"Select (1) Meritfunction or (3) Filter globalisation");
    addOption("NLPprint",OT_INTEGER,worhp_p.NLPprint,"NLP print level [-1..4]");
    addOption("PairMethod",OT_INTEGER,worhp_p.PairMethod,"Select method to determine graph colouring pairgroups");
    addOption("PenUpdEpsKSequence",OT_INTEGER,worhp_p.PenUpdEpsKSequence,"Penalty update parameter");
    addOption("UserHMstructure",OT_INTEGER,worhp_p.UserHMstructure,"Enable automatic Hessian structure generation or checking");
    addOption("MaxLScounter",OT_INTEGER,worhp_p.MaxLScounter,"Control activation of Filter acceleration heuristics");
    addOption("RegStrategy",OT_INTEGER,worhp_p.RegStrategy,"Select Hessian regularisation strategy in Filter");
    addOption("AutoQPRecovery",OT_BOOLEAN,worhp_p.AutoQPRecovery,"Enable automatic QP recovery");
    addOption("CheckStructureDF",OT_BOOLEAN,worhp_p.CheckStructureDF,"Enable structural checking of DF");
    addOption("CheckStructureDG",OT_BOOLEAN,worhp_p.CheckStructureDG,"Enable structural checking of DG");
    addOption("CheckStructureHM",OT_BOOLEAN,worhp_p.CheckStructureHM,"Enable structural checking of HM");
    addOption("CorStepRecoveryDX",OT_BOOLEAN,worhp_p.CorStepRecoveryDX,"Enable structural checking of HM");
    addOption("FGtogether",OT_BOOLEAN,worhp_p.FGtogether,"F and G cannot be evaluated separately");
    addOption("FJandND",OT_BOOLEAN,worhp_p.FJandND,"Enable Fritz-John and non-differentiable check heuristics");
    addOption("FeasibleDual",OT_BOOLEAN,worhp_p.FeasibleDual,"Activate dual feasibility mode");
    addOption("FeasibleInit",OT_BOOLEAN,worhp_p.FeasibleInit,"Activate initial feasibility mode");
    addOption("FeasibleOnly",OT_BOOLEAN,worhp_p.FeasibleOnly,"Activate feasible-only mode");
    addOption("FidifHM",OT_BOOLEAN,worhp_p.FidifHM,"Approximate Hessian by finite differences (otherwise BFGS)");
    addOption("FirstDifCentral",OT_BOOLEAN,worhp_p.FirstDifCentral,"Use central finite difference quotient for first derivatives");
    addOption("FocusOnFeas",OT_BOOLEAN,worhp_p.FocusOnFeas,"Enable Focus-on-Feasibility mode");
    addOption("InitialLMest",OT_BOOLEAN,worhp_p.InitialLMest,"Enable initial Lagrange multiplier estimate");
    addOption("KeepAcceptableSol",OT_BOOLEAN,worhp_p.KeepAcceptableSol,"Save acceptable solutions as fallback");
    addOption("LinMult",OT_BOOLEAN,worhp_p.LinMult,"Control Lagrange multiplier update");
    addOption("LowPassFilter",OT_BOOLEAN,worhp_p.LowPassFilter,"Enable lowpass-filter termination criterion");
    addOption("MatrixCC",OT_BOOLEAN,worhp_p.MatrixCC,"Not to be included into a parameter file!");
    addOption("MoreRelax",OT_BOOLEAN,worhp_p.MoreRelax,"Introduce one relaxation variable for every constraint");
    addOption("QuadraticProblem",OT_BOOLEAN,worhp_p.QuadraticProblem,"Not to be included into a parameter file!");
    addOption("RestUntilFeas",OT_BOOLEAN,worhp_p.RestUntilFeas,"Do restoration until a feasible solution is found");
    addOption("ScaleConIter",OT_BOOLEAN,worhp_p.ScaleConIter,"Scale constraints in every iteration");
    addOption("ScaledFD",OT_BOOLEAN,worhp_p.ScaledFD,"Use a scaled perturbation for finite differences");
    addOption("ScaledKKT",OT_BOOLEAN,worhp_p.ScaledKKT,"Scale KKT conditions");
    addOption("ScaledObj",OT_BOOLEAN,worhp_p.ScaledObj,"Scale the objective function");
    addOption("ScaledQP",OT_BOOLEAN,worhp_p.ScaledQP,"Scale some matrices handed to the QP");
    addOption("TakeQPSol",OT_BOOLEAN,worhp_p.TakeQPSol,"Evaluate QP search direction regardless of convergence");
    addOption("TooBig",OT_BOOLEAN,worhp_p.TooBig,"Enable too-big termination heuristics");
    addOption("UserDF",OT_BOOLEAN,worhp_p.UserDF,"Objective gradient values supplied by caller");
    addOption("UserDG",OT_BOOLEAN,worhp_p.UserDG,"Jacobian values supplied by caller");
    addOption("UserHM",OT_BOOLEAN,worhp_p.UserHM,"Hessian values supplied by caller");
    addOption("WeakActiveSet",OT_BOOLEAN,worhp_p.WeakActiveSet,"(experimental)");
    addOption("AlphaMinConst",OT_BOOLEAN,worhp_p.AlphaMinConst,"Use a constant lower bound on Armijo stepsize in Filter");
    addOption("IgnoreFilterCrit",OT_BOOLEAN,worhp_p.IgnoreFilterCrit,"Activate accelerating heuristics for Filter");
    addOption("FilterBisecAlpha",OT_BOOLEAN,worhp_p.FilterBisecAlpha,"Filter heuristic to save Armijo iterations");
    addOption("FilterIntersecAlpha",OT_BOOLEAN,worhp_p.FilterIntersecAlpha,"Filter heuristic to save Armijo iterations");
    addOption("MaxNorm",OT_BOOLEAN,worhp_p.MaxNorm,"Select max-norm instead of 1-norm in Filter");
    addOption("ReinitFilter",OT_BOOLEAN,worhp_p.ReinitFilter,"Enables Filter-reinitialisation accelerating heuristic");
    addOption("DebugMarker06",OT_INTEGER,worhp_p.DebugMarker06,"Debug marker, only needed for ASTOS integration");
    addOption("initialised",OT_BOOLEAN,worhp_p.initialised,"Automatically added initialisation flag. ");
  
    addOption("qp_ipBarrier",OT_REAL,worhp_p.qp.ipBarrier,"IP barrier parameter.");
    addOption("qp_ipComTol",OT_REAL,worhp_p.qp.ipComTol,"IP complementarity tolerance.");
    addOption("qp_ipFracBound",OT_REAL,worhp_p.qp.ipFracBound,"IP fraction-to-the-boundary parameter.");
    addOption("qp_ipLsMethod",OT_STRING,GenericType(),"Select the direct linear solver used by the IP method.","LAPACK::0|MA57: only available if provided by the user:1|SuperLU::2|PARDISO: only available if provided by the user, subject to license availability:3|MUMPS: currently Linux platforms only:5|WSMP: subject to license availability:6|MA86: experimental, only available if provided by the user:7|MA97:experimental, only available if provided by the user:8");
    setOptionByEnumValue("qp_ipLsMethod",worhp_p.qp.ipLsMethod);
    addOption("qp_ipMinAlpha",OT_REAL,worhp_p.qp.ipMinAlpha,"IP line search minimum step size.");
    addOption("qp_ipTryRelax",OT_BOOLEAN,worhp_p.qp.ipTryRelax,"Enable relaxation strategy when encountering an error.");
    addOption("qp_ipRelaxDiv",OT_REAL,worhp_p.qp.ipRelaxDiv,"The relaxation term is divided by this value if successful.");
    addOption("qp_ipRelaxMult",OT_REAL,worhp_p.qp.ipRelaxMult,"The relaxation term is multiplied by this value if unsuccessful.");
    addOption("qp_ipRelaxMax",OT_REAL,worhp_p.qp.ipRelaxMax,"Maximum relaxation value.");
    addOption("qp_ipRelaxMin",OT_REAL,worhp_p.qp.ipRelaxMin,"Mimimum relaxation value.");
    addOption("qp_ipResTol",OT_REAL,worhp_p.qp.ipResTol,"IP residuals tolerance.");
    addOption("qp_lsItMaxIter",OT_INTEGER,worhp_p.qp.lsItMaxIter,"Maximum number of iterations of the iterative linear solvers.");
    addOption("qp_lsItMethod",OT_STRING,GenericType(),"Select the iterative linear solver.","none:Deactivate; use a direct linear solver.:0|CGNR::1|CGNE::2|CGS::3|BiCGSTAB::4");
    setOptionByEnumValue("qp_lsItMethod",worhp_p.qp.lsItMethod);
    addOption("qp_lsItPrecondMethod",OT_STRING,GenericType(),"Select preconditioner for the iterative linear solver.","none:No preconditioner.:0|static:Static preconditioner (KKT-matrix with constant lower-right block).:1|full:Full KKT-matrix.:2");
    setOptionByEnumValue("qp_lsItPrecondMethod",worhp_p.qp.lsItPrecondMethod);
    addOption("qp_lsRefineMaxIter",OT_INTEGER,worhp_p.qp.lsRefineMaxIter,"Maximum number of iterative refinement steps of the direct linear solvers.");
    addOption("qp_lsScale",OT_BOOLEAN,worhp_p.qp.lsScale,"Enables scaling on linear solver level.");
    addOption("qp_lsTrySimple",OT_BOOLEAN,worhp_p.qp.lsTrySimple,"Some matrices can be solved without calling a linear equation solver.Currently only diagonal matrices are supported. Non-diagonal matrices will besolved with the chosen linear equation solver.");
    addOption("qp_lsTol",OT_REAL,worhp_p.qp.lsTol,"Tolerance for the linear solver.");
    addOption("qp_maxIter",OT_INTEGER,worhp_p.qp.maxIter,"Imposes an upper limit on the number of minor solver iterations, i.e. for thequadratic subproblem solver. If the limit is reached before convergence,WORHP will activate QP recovery strategies to prevent a solver breakdown.");
    addOption("qp_method",OT_STRING,GenericType(),"Select the solution method used by the QP solver.","ip:Interior-Point method.:1|nsn:Nonsmooth-Newton method.:2|automatic: Prefer IP and fall back to NSN on error.:12");
    setOptionByEnumValue("qp_method",worhp_p.qp.method);
    addOption("qp_nsnBeta",OT_REAL,worhp_p.qp.nsnBeta,"NSN stepsize decrease factor.");
    addOption("qp_nsnGradStep",OT_BOOLEAN,worhp_p.qp.nsnGradStep,"Enable gradient steps in the NSN method.");
    addOption("qp_nsnKKT",OT_REAL,worhp_p.qp.nsnKKT,"NSN KKT tolerance.");
    addOption("qp_nsnLsMethod",OT_STRING,GenericType(),"Select the direct linear solver used by the NSN method.","SuperLU::2|MA48: only available if provided by the user:4");
    setOptionByEnumValue("qp_nsnLsMethod",worhp_p.qp.nsnLsMethod);
    addOption("qp_nsnMinAlpha",OT_REAL,worhp_p.qp.nsnMinAlpha,"NSN line search minimum step size.");
    addOption("qp_nsnSigma",OT_REAL,worhp_p.qp.nsnSigma,"NSN line search slope parameter.");
    addOption("qp_printLevel",OT_STRING,GenericType(),"Controls the amount of QP solver output.","none:No output.:0|warn:Print warnings and errors.:1|iterations:Print iterations.:2");
    setOptionByEnumValue("qp_printLevel",worhp_p.qp.printLevel);
    addOption("qp_scaleIntern",OT_BOOLEAN,worhp_p.qp.scaleIntern,"Enable scaling on QP level.");
    addOption("qp_strict",OT_BOOLEAN,worhp_p.qp.strict,"Use strict termination criteria in IP method.");
  
    worhp_o.initialised = false;
    worhp_w.initialised = false;
    worhp_p.initialised = false;
    worhp_c.initialised = false;
  
    // The default value for ScaleConIter (False) makes IPOPT fail for decision variable bounds where lbx==ubx
    setOption("ScaleConIter",true);
  
    // qpsolver unittests fail for ScaledObj == True
    setOption("ScaledObj",false);
  
    //setOption("ScaledKKT",false);
    //setOption("ScaledFD",false);
    //setOption("ScaledQP",false);
  
  }

  WorhpInternal::~WorhpInternal(){
    if (worhp_p.initialised || worhp_o.initialised || worhp_w.initialised || worhp_c.initialised)
      WorhpFree(&worhp_o, &worhp_w, &worhp_p, &worhp_c);
  }

  void WorhpInternal::init(){

    // Call the init method of the base class
    NLPSolverInternal::init();

    // Read options
    passOptions();
  
    // Get/generate required functions
    getGradF();
    getJacG();
    if(exact_hessian_){
      hessLag();
    }
  
    // Update status?
    status_[TerminateSuccess]="TerminateSuccess";
    status_[OptimalSolution]="OptimalSolution";
    status_[SearchDirectionZero]="SearchDirectionZero";
    status_[SearchDirectionSmall]="SearchDirectionSmall";
    status_[StationaryPointFound]="StationaryPointFound";
    status_[AcceptableSolution]="AcceptableSolution";
    status_[AcceptablePrevious]="AcceptablePrevious";
    status_[FritzJohn]="FritzJohn";
    status_[NotDiffable]="NotDiffable";
    status_[Unbounded]="Unbounded";
    status_[FeasibleSolution]="FeasibleSolution";
    status_[LowPassFilterOptimal]="LowPassFilterOptimal";
    status_[LowPassFilterAcceptable]="LowPassFilterAcceptable";
    status_[TerminateError]="TerminateError";
    status_[InitError]="InitError";
    status_[DataError]="DataError";
    status_[MaxCalls]="MaxCalls";
    status_[MaxIter]="MaxIter";
    status_[MinimumStepsize]="MinimumStepsize";
    status_[QPerror]="QPerror";
    status_[ProblemInfeasible]="ProblemInfeasible";
    status_[GroupsComposition]="GroupsComposition";
    status_[TooBig]="TooBig";
    status_[Timeout]="Timeout";
    status_[FDError]="FDError";
    status_[LocalInfeas]="LocalInfeas";
    status_[LicenseError]="LicenseError. Please set the WORHP_LICENSE_FILE environmental variable with the full path to the license file";
    status_[TerminatedByUser]="TerminatedByUser";
    status_[FunctionErrorF]="FunctionErrorF";
    status_[FunctionErrorG]="FunctionErrorG";
    status_[FunctionErrorDF]="FunctionErrorDF";
    status_[FunctionErrorDG]="FunctionErrorDG";
    status_[FunctionErrorHM]="FunctionErrorHM";
  
    worhp_o.initialised = false;
    worhp_w.initialised = false;
    worhp_p.initialised = false;
    worhp_c.initialised = false;  
  }

  void WorhpInternal::setQPOptions() {
    setOption("UserHM", true);
  }

  void WorhpInternal::passOptions() {

    if (hasSetOption("Ares")) {
      std::vector<int> ares = getOption("Ares");
      std::copy(ares.begin(),ares.begin()+NAres,worhp_p.Ares);
    }
  
    if(hasSetOption("UserHM")){
      exact_hessian_ = getOption("UserHM");
    } else {
      exact_hessian_ = true;
      setOption("UserHM",true);
    }
  
    /**
     *  Autogenerated from C_worhp_aux.h with params.pl
     *
     */
  
    if (hasSetOption("AcceptTolFeas")) worhp_p.AcceptTolFeas = getOption("AcceptTolFeas");
    if (hasSetOption("AcceptTolOpti")) worhp_p.AcceptTolOpti = getOption("AcceptTolOpti");
    if (hasSetOption("ArmijoBeta")) worhp_p.ArmijoBeta = getOption("ArmijoBeta");
    if (hasSetOption("ArmijoMaxAlpha")) worhp_p.ArmijoMaxAlpha = getOption("ArmijoMaxAlpha");
    if (hasSetOption("ArmijoMinAlpha")) worhp_p.ArmijoMinAlpha = getOption("ArmijoMinAlpha");
    if (hasSetOption("ArmijoMinAlphaRec")) worhp_p.ArmijoMinAlphaRec = getOption("ArmijoMinAlphaRec");
    if (hasSetOption("ArmijoSigma")) worhp_p.ArmijoSigma = getOption("ArmijoSigma");
    if (hasSetOption("BettsFactor")) worhp_p.BettsFactor = getOption("BettsFactor");
    if (hasSetOption("BettsPoint")) worhp_p.BettsPoint = getOption("BettsPoint");
    if (hasSetOption("BoundTolFac")) worhp_p.BoundTolFac = getOption("BoundTolFac");
    if (hasSetOption("CorStepBettsSum")) worhp_p.CorStepBettsSum = getOption("CorStepBettsSum");
    if (hasSetOption("CorStepConvio")) worhp_p.CorStepConvio = getOption("CorStepConvio");
    if (hasSetOption("CorStepConStop")) worhp_p.CorStepConStop = getOption("CorStepConStop");
    if (hasSetOption("CorStepPFactor")) worhp_p.CorStepPFactor = getOption("CorStepPFactor");
    if (hasSetOption("CorStepPMax")) worhp_p.CorStepPMax = getOption("CorStepPMax");
    if (hasSetOption("CheckFJ")) worhp_p.CheckFJ = getOption("CheckFJ");
    if (hasSetOption("CurvBCond")) worhp_p.CurvBCond = getOption("CurvBCond");
    if (hasSetOption("CurvBFac")) worhp_p.CurvBFac = getOption("CurvBFac");
    if (hasSetOption("CurvCond")) worhp_p.CurvCond = getOption("CurvCond");
    if (hasSetOption("CurvFac")) worhp_p.CurvFac = getOption("CurvFac");
    if (hasSetOption("CutLength")) worhp_p.CutLength = getOption("CutLength");
    if (hasSetOption("FeasibleInitTol")) worhp_p.FeasibleInitTol = getOption("FeasibleInitTol");
    if (hasSetOption("FidifEps")) worhp_p.FidifEps = getOption("FidifEps");
    if (hasSetOption("FocusOnFeasFactor")) worhp_p.FocusOnFeasFactor = getOption("FocusOnFeasFactor");
    if (hasSetOption("Infty")) worhp_p.Infty = getOption("Infty");
    if (hasSetOption("InftyUnbounded")) worhp_p.InftyUnbounded = getOption("InftyUnbounded");
    if (hasSetOption("LMestQPipComTol")) worhp_p.LMestQPipComTol = getOption("LMestQPipComTol");
    if (hasSetOption("LMestQPipResTol")) worhp_p.LMestQPipResTol = getOption("LMestQPipResTol");
    if (hasSetOption("LowPassAlphaF")) worhp_p.LowPassAlphaF = getOption("LowPassAlphaF");
    if (hasSetOption("LowPassAlphaG")) worhp_p.LowPassAlphaG = getOption("LowPassAlphaG");
    if (hasSetOption("LowPassAlphaMerit")) worhp_p.LowPassAlphaMerit = getOption("LowPassAlphaMerit");
    if (hasSetOption("Ma57PivotThresh")) worhp_p.Ma57PivotThresh = getOption("Ma57PivotThresh");
    if (hasSetOption("MeritGradTol")) worhp_p.MeritGradTol = getOption("MeritGradTol");
    if (hasSetOption("PenUpdEpsKFac")) worhp_p.PenUpdEpsKFac = getOption("PenUpdEpsKFac");
    if (hasSetOption("PenUpdEpsBar")) worhp_p.PenUpdEpsBar = getOption("PenUpdEpsBar");
    if (hasSetOption("PenUpdMaxDeltaK")) worhp_p.PenUpdMaxDeltaK = getOption("PenUpdMaxDeltaK");
    if (hasSetOption("PenUpdMaxFac")) worhp_p.PenUpdMaxFac = getOption("PenUpdMaxFac");
    if (hasSetOption("PenUpdRBar")) worhp_p.PenUpdRBar = getOption("PenUpdRBar");
    if (hasSetOption("PrecisionF")) worhp_p.PrecisionF = getOption("PrecisionF");
    if (hasSetOption("PrecisionG")) worhp_p.PrecisionG = getOption("PrecisionG");
    if (hasSetOption("QPscaleParam")) worhp_p.QPscaleParam = getOption("QPscaleParam");
    if (hasSetOption("RelaxMaxDelta")) worhp_p.RelaxMaxDelta = getOption("RelaxMaxDelta");
    if (hasSetOption("RelaxMaxPen")) worhp_p.RelaxMaxPen = getOption("RelaxMaxPen");
    if (hasSetOption("RelaxRho")) worhp_p.RelaxRho = getOption("RelaxRho");
    if (hasSetOption("RelaxStart")) worhp_p.RelaxStart = getOption("RelaxStart");
    if (hasSetOption("ScaleFacObj")) worhp_p.ScaleFacObj = getOption("ScaleFacObj");
    if (hasSetOption("ScaleFacQP")) worhp_p.ScaleFacQP = getOption("ScaleFacQP");
    if (hasSetOption("StartBettsTau")) worhp_p.StartBettsTau = getOption("StartBettsTau");
    if (hasSetOption("Timeout")) worhp_p.Timeout = getOption("Timeout");
    if (hasSetOption("TolComp")) worhp_p.TolComp = getOption("TolComp");
    if (hasSetOption("TolFeas")) worhp_p.TolFeas = getOption("TolFeas");
    if (hasSetOption("TolOpti")) worhp_p.TolOpti = getOption("TolOpti");
    if (hasSetOption("TolWeakActive")) worhp_p.TolWeakActive = getOption("TolWeakActive");
    if (hasSetOption("TooBigCV")) worhp_p.TooBigCV = getOption("TooBigCV");
    if (hasSetOption("TooBigKKT")) worhp_p.TooBigKKT = getOption("TooBigKKT");
    if (hasSetOption("eps")) worhp_p.eps = getOption("eps");
    if (hasSetOption("IncreaseIWS")) worhp_p.IncreaseIWS = getOption("IncreaseIWS");
    if (hasSetOption("IncreaseRWS")) worhp_p.IncreaseRWS = getOption("IncreaseRWS");
    if (hasSetOption("FilterGammaCV")) worhp_p.FilterGammaCV = getOption("FilterGammaCV");
    if (hasSetOption("FilterGammaF")) worhp_p.FilterGammaF = getOption("FilterGammaF");
    if (hasSetOption("GammaAlpha")) worhp_p.GammaAlpha = getOption("GammaAlpha");
    if (hasSetOption("IncBettsTau")) worhp_p.IncBettsTau = getOption("IncBettsTau");
    if (hasSetOption("IncBettsTauMore")) worhp_p.IncBettsTauMore = getOption("IncBettsTauMore");
    if (hasSetOption("MinBettsTau")) worhp_p.MinBettsTau = getOption("MinBettsTau");
    if (hasSetOption("ReduceBettsTau")) worhp_p.ReduceBettsTau = getOption("ReduceBettsTau");
    if (hasSetOption("SwitchingDelta")) worhp_p.SwitchingDelta = getOption("SwitchingDelta");
    if (hasSetOption("SwitchingSF")) worhp_p.SwitchingSF = getOption("SwitchingSF");
    if (hasSetOption("SwitchingSCV")) worhp_p.SwitchingSCV = getOption("SwitchingSCV");
    if (hasSetOption("BFGSmethod")) worhp_p.BFGSmethod = getOption("BFGSmethod");
    if (hasSetOption("BFGSrestart")) worhp_p.BFGSrestart = getOption("BFGSrestart");
    if (hasSetOption("BFGSmaxblockSize")) worhp_p.BFGSmaxblockSize = getOption("BFGSmaxblockSize");
    if (hasSetOption("BFGSminblockSize")) worhp_p.BFGSminblockSize = getOption("BFGSminblockSize");
    if (hasSetOption("CorStepMaxIter")) worhp_p.CorStepMaxIter = getOption("CorStepMaxIter");
    if (hasSetOption("CorStepMethod")) worhp_p.CorStepMethod = getOption("CorStepMethod");
    if (hasSetOption("CorStepMode")) worhp_p.CorStepMode = getOption("CorStepMode");
    if (hasSetOption("GroupMethod")) worhp_p.GroupMethod = getOption("GroupMethod");
    if (hasSetOption("LogLevel")) worhp_p.LogLevel = getOption("LogLevel");
    if (hasSetOption("LogResult")) worhp_p.LogResult = getOption("LogResult");
    if (hasSetOption("MaxCalls")) worhp_p.MaxCalls = getOption("MaxCalls");
    if (hasSetOption("MaxForce")) worhp_p.MaxForce = getOption("MaxForce");
    if (hasSetOption("MaxGPart")) worhp_p.MaxGPart = getOption("MaxGPart");
    if (hasSetOption("MaxIter")) worhp_p.MaxIter = getOption("MaxIter");
    if (hasSetOption("MeritFunction")) worhp_p.MeritFunction = getOption("MeritFunction");
    if (hasSetOption("NLPmethod")) worhp_p.NLPmethod = getOption("NLPmethod");
    if (hasSetOption("NLPprint")) worhp_p.NLPprint = getOption("NLPprint");
    if (hasSetOption("PairMethod")) worhp_p.PairMethod = getOption("PairMethod");
    if (hasSetOption("PenUpdEpsKSequence")) worhp_p.PenUpdEpsKSequence = getOption("PenUpdEpsKSequence");
    if (hasSetOption("UserHMstructure")) worhp_p.UserHMstructure = getOption("UserHMstructure");
    if (hasSetOption("MaxLScounter")) worhp_p.MaxLScounter = getOption("MaxLScounter");
    if (hasSetOption("RegStrategy")) worhp_p.RegStrategy = getOption("RegStrategy");
    if (hasSetOption("AutoQPRecovery")) worhp_p.AutoQPRecovery = getOption("AutoQPRecovery");
    if (hasSetOption("CheckStructureDF")) worhp_p.CheckStructureDF = getOption("CheckStructureDF");
    if (hasSetOption("CheckStructureDG")) worhp_p.CheckStructureDG = getOption("CheckStructureDG");
    if (hasSetOption("CheckStructureHM")) worhp_p.CheckStructureHM = getOption("CheckStructureHM");
    if (hasSetOption("CorStepRecoveryDX")) worhp_p.CorStepRecoveryDX = getOption("CorStepRecoveryDX");
    if (hasSetOption("FGtogether")) worhp_p.FGtogether = getOption("FGtogether");
    if (hasSetOption("FJandND")) worhp_p.FJandND = getOption("FJandND");
    if (hasSetOption("FeasibleDual")) worhp_p.FeasibleDual = getOption("FeasibleDual");
    if (hasSetOption("FeasibleInit")) worhp_p.FeasibleInit = getOption("FeasibleInit");
    if (hasSetOption("FeasibleOnly")) worhp_p.FeasibleOnly = getOption("FeasibleOnly");
    if (hasSetOption("FidifHM")) worhp_p.FidifHM = getOption("FidifHM");
    if (hasSetOption("FirstDifCentral")) worhp_p.FirstDifCentral = getOption("FirstDifCentral");
    if (hasSetOption("FocusOnFeas")) worhp_p.FocusOnFeas = getOption("FocusOnFeas");
    if (hasSetOption("InitialLMest")) worhp_p.InitialLMest = getOption("InitialLMest");
    if (hasSetOption("KeepAcceptableSol")) worhp_p.KeepAcceptableSol = getOption("KeepAcceptableSol");
    if (hasSetOption("LinMult")) worhp_p.LinMult = getOption("LinMult");
    if (hasSetOption("LowPassFilter")) worhp_p.LowPassFilter = getOption("LowPassFilter");
    if (hasSetOption("MatrixCC")) worhp_p.MatrixCC = getOption("MatrixCC");
    if (hasSetOption("MoreRelax")) worhp_p.MoreRelax = getOption("MoreRelax");
    if (hasSetOption("QuadraticProblem")) worhp_p.QuadraticProblem = getOption("QuadraticProblem");
    if (hasSetOption("RestUntilFeas")) worhp_p.RestUntilFeas = getOption("RestUntilFeas");
    if (hasSetOption("ScaleConIter")) worhp_p.ScaleConIter = getOption("ScaleConIter");
    if (hasSetOption("ScaledFD")) worhp_p.ScaledFD = getOption("ScaledFD");
    if (hasSetOption("ScaledKKT")) worhp_p.ScaledKKT = getOption("ScaledKKT");
    if (hasSetOption("ScaledObj")) worhp_p.ScaledObj = getOption("ScaledObj");
    if (hasSetOption("ScaledQP")) worhp_p.ScaledQP = getOption("ScaledQP");
    if (hasSetOption("TakeQPSol")) worhp_p.TakeQPSol = getOption("TakeQPSol");
    if (hasSetOption("TooBig")) worhp_p.TooBig = getOption("TooBig");
    if (hasSetOption("UserDF")) worhp_p.UserDF = getOption("UserDF");
    if (hasSetOption("UserDG")) worhp_p.UserDG = getOption("UserDG");
    if (hasSetOption("UserHM")) worhp_p.UserHM = getOption("UserHM");
    if (hasSetOption("WeakActiveSet")) worhp_p.WeakActiveSet = getOption("WeakActiveSet");
    if (hasSetOption("AlphaMinConst")) worhp_p.AlphaMinConst = getOption("AlphaMinConst");
    if (hasSetOption("IgnoreFilterCrit")) worhp_p.IgnoreFilterCrit = getOption("IgnoreFilterCrit");
    if (hasSetOption("FilterBisecAlpha")) worhp_p.FilterBisecAlpha = getOption("FilterBisecAlpha");
    if (hasSetOption("FilterIntersecAlpha")) worhp_p.FilterIntersecAlpha = getOption("FilterIntersecAlpha");
    if (hasSetOption("MaxNorm")) worhp_p.MaxNorm = getOption("MaxNorm");
    if (hasSetOption("ReinitFilter")) worhp_p.ReinitFilter = getOption("ReinitFilter");
    if (hasSetOption("DebugMarker06")) worhp_p.DebugMarker06 = getOption("DebugMarker06");
    if (hasSetOption("initialised")) worhp_p.initialised = getOption("initialised"); 
  
    if (hasSetOption("qp_ipBarrier")) worhp_p.qp.ipBarrier = getOption("qp_ipBarrier");
    if (hasSetOption("qp_ipComTol")) worhp_p.qp.ipComTol = getOption("qp_ipComTol");
    if (hasSetOption("qp_ipFracBound")) worhp_p.qp.ipFracBound = getOption("qp_ipFracBound");
    if (hasSetOption("qp_ipLsMethod")) worhp_p.qp.ipLsMethod = getOptionEnumValue("qp_ipLsMethod");
    if (hasSetOption("qp_ipMinAlpha")) worhp_p.qp.ipMinAlpha = getOption("qp_ipMinAlpha");
    if (hasSetOption("qp_ipTryRelax")) worhp_p.qp.ipTryRelax = getOption("qp_ipTryRelax");
    if (hasSetOption("qp_ipRelaxDiv")) worhp_p.qp.ipRelaxDiv = getOption("qp_ipRelaxDiv");
    if (hasSetOption("qp_ipRelaxMult")) worhp_p.qp.ipRelaxMult = getOption("qp_ipRelaxMult");
    if (hasSetOption("qp_ipRelaxMax")) worhp_p.qp.ipRelaxMax = getOption("qp_ipRelaxMax");
    if (hasSetOption("qp_ipRelaxMin")) worhp_p.qp.ipRelaxMin = getOption("qp_ipRelaxMin");
    if (hasSetOption("qp_ipResTol")) worhp_p.qp.ipResTol = getOption("qp_ipResTol");
    if (hasSetOption("qp_lsItMaxIter")) worhp_p.qp.lsItMaxIter = getOption("qp_lsItMaxIter");
    if (hasSetOption("qp_lsItMethod")) worhp_p.qp.lsItMethod = getOptionEnumValue("qp_lsItMethod");
    if (hasSetOption("qp_lsItPrecondMethod")) worhp_p.qp.lsItPrecondMethod = getOptionEnumValue("qp_lsItPrecondMethod");
    if (hasSetOption("qp_lsRefineMaxIter")) worhp_p.qp.lsRefineMaxIter = getOption("qp_lsRefineMaxIter");
    if (hasSetOption("qp_lsScale")) worhp_p.qp.lsScale = getOption("qp_lsScale");
    if (hasSetOption("qp_lsTrySimple")) worhp_p.qp.lsTrySimple = getOption("qp_lsTrySimple");
    if (hasSetOption("qp_lsTol")) worhp_p.qp.lsTol = getOption("qp_lsTol");
    if (hasSetOption("qp_maxIter")) worhp_p.qp.maxIter = getOption("qp_maxIter");
    if (hasSetOption("qp_method")) worhp_p.qp.method = getOptionEnumValue("qp_method");
    if (hasSetOption("qp_nsnBeta")) worhp_p.qp.nsnBeta = getOption("qp_nsnBeta");
    if (hasSetOption("qp_nsnGradStep")) worhp_p.qp.nsnGradStep = getOption("qp_nsnGradStep");
    if (hasSetOption("qp_nsnKKT")) worhp_p.qp.nsnKKT = getOption("qp_nsnKKT");
    if (hasSetOption("qp_nsnLsMethod")) worhp_p.qp.nsnLsMethod = getOptionEnumValue("qp_nsnLsMethod");
    if (hasSetOption("qp_nsnMinAlpha")) worhp_p.qp.nsnMinAlpha = getOption("qp_nsnMinAlpha");
    if (hasSetOption("qp_nsnSigma")) worhp_p.qp.nsnSigma = getOption("qp_nsnSigma");
    if (hasSetOption("qp_printLevel")) worhp_p.qp.printLevel = getOptionEnumValue("qp_printLevel");
    if (hasSetOption("qp_scaleIntern")) worhp_p.qp.scaleIntern = getOption("qp_scaleIntern");
    if (hasSetOption("qp_strict")) worhp_p.qp.strict = getOption("qp_strict");
  
  }

  void WorhpInternal::checkinit() {
    // Must Worhp be re-initialised? This is happens when freeX or freeG changes
    bool dirty = false;
  
    // Collect the new freeX in a temporary variable
    std::vector<int> freeXi;
    nonfreeX_.clear();
  
    // Populate temporary freeX
    for (int i=0;i<input(NLP_SOLVER_LBX).size();++i) {
      //if (input(NLP_SOLVER_LBX).at(i)!=input(NLP_SOLVER_UBX).at(i)) {freeXi.push_back(i);} else {nonfreeX_.push_back(i);}
      if (true) {freeXi.push_back(i);} else {nonfreeX_.push_back(i);}
    }
  
    // Check if temprary freeX equals previous freeX and set dirty if so
    if (freeXi.size() == freeX_.size()) {
      dirty = dirty || !std::equal(freeXi.begin(), freeXi.end(), freeX_.begin());
    } else {
      dirty = true;
    }
    double inf = numeric_limits<double>::infinity();
  
    // Collect the new freeG in a temporary variable
    std::vector<int> freeGi;
    nonfreeG_.clear();
  
    // Populate temporary freeG
    for (int i=0;i<input(NLP_SOLVER_LBG).size();++i) {
      if (input(NLP_SOLVER_LBG).at(i)==-inf && input(NLP_SOLVER_UBG).at(i) == inf) {freeGi.push_back(i);} else {nonfreeG_.push_back(i);}
    }

    // Check if temporary freeG equals previous freeG and set dirty if so
    if (freeGi.size() == freeG_.size()) {
      dirty = dirty || !std::equal(freeGi.begin(), freeGi.end(), freeG_.begin());
    } else {
      dirty = true;
    }

    bool p_init_backup = worhp_p.initialised;
    worhp_p.initialised = false;
    if (worhp_o.initialised || worhp_w.initialised || worhp_c.initialised)
      WorhpFree(&worhp_o, &worhp_w, &worhp_p, &worhp_c);
    worhp_p.initialised = p_init_backup;
  
    /// Control data structure needs to be reset every time
    worhp_c.initialised = false;
    worhp_w.initialised = false;
    worhp_o.initialised = false;
  
    // Fast return if not dirty
    //if (!dirty) return;
    
    // Save temporary freeX
    freeX_ = freeXi;
  
    // Save temporary freeG
    freeG_ = freeGi;
  
    casadi_log("WorhpInternal::checkinit - # decision vars: " << input(NLP_SOLVER_LBX).size() << " (" << freeX_.size() << " free - "  <<  nonfreeX_.size() << " nonfree).");
    casadi_log("WorhpInternal::checkinit - # constraints:   " << input(NLP_SOLVER_UBX).size() << " (" << freeG_.size() << " free - "  <<  nonfreeG_.size() << " nonfree).");
  
    // Helper matrices for free and non-free X
    MX nonfreeX = MX("nonfreeX",nonfreeX_.size());
    MX freeX = MX("free",freeX_.size());
  
    MX nonfreeG = MX("nonfreeG",nonfreeG_.size());
  
    // Create modified nlp that does not contain the non-free X
    std::vector< MX > nlpmod_in = nlp_.symbolicInput();
    std::vector< MX > nlp_in = nlpmod_in;
    nlpmod_in[0] = freeX;
    nlpmod_in.push_back(nonfreeX);
    nlp_in.at(0) = MX(nlp_in.at(0).sparsity(),0);
    nlp_in.at(0)[nonfreeX_] = nonfreeX;
    nlp_in.at(0)[freeX_] = freeX;
    nlpmod_ = MXFunction(nlpmod_in,nlp_.call(nlp_in));
    nlpmod_.init(); 
  
    // Create modified H that does not contain the non-free X
    if (!hessLag_.isNull()) {
      std::vector< MX > Hmod_in = hessLag_.symbolicInput();
      std::vector< MX > H_in = Hmod_in;
    
      Hmod_in.at(NL_X) = freeX;
      Hmod_in.at(NL_NUM_IN+NL_G) = nonfreeG;
      Hmod_in.push_back(nonfreeX);
      H_in.at(NL_X) = MX(H_in.at(NL_X).sparsity(),0);
      H_in.at(NL_X)[nonfreeX_] = nonfreeX;
      H_in.at(NL_X)[freeX_] =  freeX;
      H_in.at(NL_NUM_IN+NL_G) = MX(H_in.at(NL_NUM_IN+NL_G).sparsity(),0);
      H_in.at(NL_NUM_IN+NL_G)[nonfreeG_] = nonfreeG;
      H_in.at(NL_NUM_IN+NL_G)[freeG_] = 0;
    
      Hmod_ = MXFunction(Hmod_in,hessLag_.call(H_in).at(0)(freeX_,freeX_));
      Hmod_.init(); 
    }
  
    // Create modified J that does not contain the non-free X, nor the free G
    if (!jacG_.isNull()) {
      std::vector< MX > Jmod_in = jacG_.symbolicInput();
      std::vector< MX > J_in = Jmod_in;
      Jmod_in.at(0) = freeX;
      Jmod_in.push_back(nonfreeX);
      J_in.at(0) = MX(J_in.at(0).sparsity(),0);
      J_in.at(0)[nonfreeX_] = nonfreeX;
      J_in.at(0)[freeX_] = freeX;
      MX J_call = jacG_.call(J_in).at(0);
      if (J_call.isNull()) {
	Jmod_ = MXFunction(Jmod_in,MX());
      } else {
	Jmod_ = MXFunction(Jmod_in,J_call(nonfreeG_,freeX_));
      }
      Jmod_.init(); 
    }
  
    // Create modified GF that does not contain the non-free X
    if (!gradF_.isNull()) {
      std::vector< MX > GFmod_in = gradF_.symbolicInput();
      std::vector< MX > GF_in = GFmod_in;
      GFmod_in.at(0) = freeX;
      GFmod_in.push_back(nonfreeX);
      GF_in.at(0) = MX(GF_in.at(0).sparsity(),0);
      GF_in.at(0)[nonfreeX_] = nonfreeX;
      GF_in.at(0)[freeX_] = freeX;
      GFmod_ = MXFunction(GFmod_in,gradF_.call(GF_in).at(0)(freeX_));
      GFmod_.init(); 
    }
  
    worhp_o.n = freeX_.size();  // Number of variables
    worhp_o.m = nonfreeG_.size();  // Number of constraints
  
    // Worhp uses the CS format internally, hence it is the preferred sparse matrix format.
  
    worhp_w.DF.nnz = GFmod_.output().size(); // Gradient of f
    if (worhp_o.m>0) {
      worhp_w.DG.nnz = Jmod_.output().size();  // Jacobian of G
    } else {
      worhp_w.DG.nnz = 0;
    }

    if (exact_hessian_){
      std::vector< MX > input = Hmod_.symbolicInput();
      MX H = Hmod_.call(input).at(0);
      H = vertcat(vec(H(lowerSparsity(H.sparsity(),false))),vec(H(sp_diag(worhp_o.n))));
    
      H_tril_ = MXFunction(input,H);
      H_tril_.init();
    
      worhp_w.HM.nnz = H_tril_.output().size();
    
      std::stringstream ss;
      ss << "Allocating space for " << worhp_w.HM.nnz << " hessian entries" << std::endl;
      log(ss.str());
    } else {
      worhp_w.HM.nnz = 0;
    }

  
    /* Data structure initialisation. */
    WorhpInit(&worhp_o, &worhp_w, &worhp_p, &worhp_c);
    if (worhp_c.status != FirstCall) {
      casadi_error("Main: Initialisation failed. Status: " << formatStatus(worhp_c.status));
    }

    if (worhp_w.DF.NeedStructure) {
      vector<int> row,col;
      GFmod_.output().sparsity().getSparsity(col,row); // transpose
    
      casadi_assert(row.size()==worhp_w.DF.nnz);
      casadi_assert(worhp_w.DF.nnz<=worhp_w.DF.dim_row);
    
      for (int i=0;i<row.size();++i) worhp_w.DF.row[i] = row[i] + 1; // Index-1 based
    
    }
  
    if (worhp_o.m>0 && worhp_w.DG.NeedStructure) {

    
      vector<int> row,col;
      trans(Jmod_.output()).sparsity().getSparsity(col,row);
      std::vector< MX > J = Jmod_.symbolicInput();
      
      casadi_assert(col.size()==worhp_w.DG.nnz);
      casadi_assert(row.size()==worhp_w.DG.nnz);
    
      casadi_assert(worhp_w.DG.nnz<=worhp_w.DG.dim_row);
      casadi_assert(worhp_w.DG.nnz<=worhp_w.DG.dim_col);
    
      for (int i=0;i<col.size();++i) worhp_w.DG.col[i] = col[i] + 1;
      for (int i=0;i<row.size();++i) worhp_w.DG.row[i] = row[i] + 1;
    
    }
  
    

    if (exact_hessian_){
      log("generate_hessian sparsity");
      if (worhp_w.HM.NeedStructure) {
	vector<int> row,col;
	trans(lowerSparsity(Hmod_.output().sparsity(),false)).getSparsity(col,row);

	for (int i=0;i<col.size();++i) worhp_w.HM.col[i] = col[i] + 1;
	for (int i=0;i<row.size();++i) worhp_w.HM.row[i] = row[i] + 1;
      
	vector<int> rowd,cold;
	Hmod_.output()(sp_diag(worhp_o.n)).sparsity().getSparsity(rowd,cold);
      
	casadi_assert(worhp_w.HM.nnz<=worhp_w.HM.dim_row);
	casadi_assert(worhp_w.HM.nnz<=worhp_w.HM.dim_col);
      
	casadi_assert(cold.size()+col.size()==worhp_w.HM.nnz);
	casadi_assert(rowd.size()+row.size()==worhp_w.HM.nnz);
      
	for (int i=0;i<cold.size();++i) worhp_w.HM.col[i+col.size()] = cold[i] + 1;
	for (int i=0;i<rowd.size();++i) worhp_w.HM.row[i+row.size()] = rowd[i] + 1;


      }
    }
  
  }


  std::string WorhpInternal::formatStatus(int status) const {
    if (status_.find(status)==status_.end()) {
      std::stringstream ss;
      ss << "Unknown status: " << status;
      return ss.str();
    } else {
      return (*status_.find(status)).second;
    }
  }

  void WorhpInternal::evaluate(int nfdir, int nadir){
    log("WorhpInternal::evaluate");
    casadi_assert(nfdir==0 && nadir==0);

    checkinit();
  
    checkInitialBounds();
  
    // Reset the counters
    t_eval_f_ = t_eval_grad_f_ = t_eval_g_ = t_eval_jac_g_ = t_eval_h_ = t_callback_fun_ = t_callback_prepare_ = t_mainloop_ = 0;
  
    DMatrix bx = input(NLP_SOLVER_LBX)[nonfreeX_];
    DMatrix lbx = input(NLP_SOLVER_LBX)[freeX_];
    DMatrix ubx = input(NLP_SOLVER_UBX)[freeX_];
  
    if (!nlpmod_.isNull()) nlpmod_.setInput(bx,nlpmod_.getNumInputs()-1);
    if (!Hmod_.isNull()) Hmod_.setInput(bx,Hmod_.getNumInputs()-1);
    if (!H_tril_.isNull()) H_tril_.setInput(bx,H_tril_.getNumInputs()-1);
    if (!Jmod_.isNull()) Jmod_.setInput(bx,Jmod_.getNumInputs()-1);
    if (!GFmod_.isNull()) GFmod_.setInput(bx,GFmod_.getNumInputs()-1);
  
    log("WorhpInternal::copying data");
  
    input(NLP_SOLVER_X0)[freeX_].getArray(worhp_o.X,worhp_o.n);
    lbx.getArray(worhp_o.XL,worhp_o.n);
    ubx.getArray(worhp_o.XU,worhp_o.n);
  
    DMatrix lbg = input(NLP_SOLVER_LBG)[nonfreeG_];
    DMatrix ubg = input(NLP_SOLVER_UBG)[nonfreeG_];

    output(NLP_SOLVER_LAM_X)[freeX_].getArray(worhp_o.Lambda,worhp_o.n);
    if (worhp_o.m>0) input(NLP_SOLVER_LAM_G0)[nonfreeG_].getArray(worhp_o.Mu,worhp_o.m);

    if (worhp_o.m>0) lbg.getArray(worhp_o.GL,worhp_o.m);
    if (worhp_o.m>0) ubg.getArray(worhp_o.GU,worhp_o.m);
  
    //for (int i=0;i<lbx.size();++i) {
    //  casadi_assert_message(lbx.at(i)!=ubx.at(i),"WorhpSolver::evaluate: Worhp cannot handle the case when LBX == UBX. You have that case at non-zero " << i << " , which has value " << ubx.at(i) << ".");
    //}
  
    double inf = numeric_limits<double>::infinity();
  
    for (int i=0;i<lbg.size();++i) {
      casadi_assert_message(!(lbg.at(i)==-inf && ubg.at(i) == inf),"WorhpSolver::evaluate: Worhp cannot handle the case when both LBG and UBG are infinite. You have that case at non-zero " << i << ".");
    }

    output(NLP_SOLVER_X)[nonfreeX_] = bx;
    output(NLP_SOLVER_LAM_X)[nonfreeX_] = 0;
    output(NLP_SOLVER_LAM_G)[freeG_] = 0;
  
  
    std::vector<double> tempn(worhp_o.n,0);
    std::vector<double> tempm(worhp_o.m,0);
  
    log("WorhpInternal::starting iteration");
    double time1 = clock();
  
    // Reverse Communication loop
    while(worhp_c.status < TerminateSuccess &&  worhp_c.status > TerminateError) {
      if (GetUserAction(&worhp_c, callWorhp)) {
	Worhp(&worhp_o, &worhp_w, &worhp_p, &worhp_c);
      }

      if (GetUserAction(&worhp_c, iterOutput)) {
	if (!callback_.isNull()) {
	  double time1 = clock();
	  // Copy outputs
	  copy(worhp_o.X,worhp_o.X+worhp_o.n,tempn.begin());
	  if (!callback_.input(NLP_SOLVER_X).empty()) callback_.input(NLP_SOLVER_X)[freeX_] = tempn;
	  callback_.input(NLP_SOLVER_F)[0] = worhp_o.F;
	  if (worhp_o.m>0) copy(worhp_o.G,worhp_o.G+worhp_o.m,tempm.begin());
	  if (!callback_.input(NLP_SOLVER_G).empty()) callback_.input(NLP_SOLVER_G)[nonfreeG_] = tempm;
	  copy(worhp_o.Lambda,worhp_o.Lambda+worhp_o.n,tempn.begin());
	  if (!callback_.input(NLP_SOLVER_LAM_X).empty()) callback_.input(NLP_SOLVER_LAM_X)[freeX_] = tempn;
	  if (worhp_o.m>0) copy(worhp_o.Mu,worhp_o.Mu+worhp_o.m,tempm.begin());
	  if (!callback_.input(NLP_SOLVER_LAM_G).empty()) callback_.input(NLP_SOLVER_LAM_G)[nonfreeG_]=tempm;
	  double time2 = clock();
	  t_callback_prepare_ += double(time2-time1)/CLOCKS_PER_SEC;
	  time1 = clock();
	  callback_.evaluate();
	  time2 = clock();
	  t_callback_fun_ += double(time2-time1)/CLOCKS_PER_SEC;
	}
    
	IterationOutput(&worhp_o, &worhp_w, &worhp_p, &worhp_c);
	DoneUserAction(&worhp_c, iterOutput);
      }

      if (GetUserAction(&worhp_c, evalF)) {
	eval_f(worhp_o.X, worhp_w.ScaleObj, worhp_o.F);
	DoneUserAction(&worhp_c, evalF);
      }

      if (GetUserAction(&worhp_c, evalG)) {
	eval_g(worhp_o.X, worhp_o.G);
	DoneUserAction(&worhp_c, evalG);
      }

      if (GetUserAction(&worhp_c, evalDF)) {
	eval_grad_f(worhp_o.X, worhp_w.ScaleObj, worhp_w.DF.val);
	DoneUserAction(&worhp_c, evalDF);
      }

      if (GetUserAction(&worhp_c, evalDG)) {
	eval_jac_g(worhp_o.X,worhp_w.DG.val);
	DoneUserAction(&worhp_c, evalDG);
      }

      if (GetUserAction(&worhp_c, evalHM)) {
	eval_h(worhp_o.X, worhp_w.ScaleObj, worhp_o.Mu, worhp_w.HM.val);
	DoneUserAction(&worhp_c, evalHM);
      }
    
      if (GetUserAction(&worhp_c, fidif)) {
	WorhpFidif(&worhp_o, &worhp_w, &worhp_p, &worhp_c);
      }

    }
    double time2 = clock();
    t_mainloop_ += double(time2-time1)/CLOCKS_PER_SEC;
  
    // Copy outputs
    copy(worhp_o.X,worhp_o.X+worhp_o.n,tempn.begin());output(NLP_SOLVER_X)[freeX_] = tempn;   
    output(NLP_SOLVER_F)[0] = worhp_o.F;
    if (worhp_o.m>0) copy(worhp_o.G,worhp_o.G+worhp_o.m,tempm.begin());output(NLP_SOLVER_G)[nonfreeG_] = tempm;
    copy(worhp_o.Lambda,worhp_o.Lambda+worhp_o.n,tempn.begin());output(NLP_SOLVER_LAM_X)[freeX_] = tempn;
    if (worhp_o.m>0) copy(worhp_o.Mu,worhp_o.Mu+worhp_o.m,tempm.begin());output(NLP_SOLVER_LAM_G)[nonfreeG_]=tempm;
  
    StatusMsg(&worhp_o, &worhp_w, &worhp_p, &worhp_c);
 
    if (hasOption("print_time") && bool(getOption("print_time"))) {
      // Write timings
      cout << "time spent in eval_f: " << t_eval_f_ << " s." << endl;
      cout << "time spent in eval_grad_f: " << t_eval_grad_f_ << " s." << endl;
      cout << "time spent in eval_g: " << t_eval_g_ << " s." << endl;
      cout << "time spent in eval_jac_g: " << t_eval_jac_g_ << " s." << endl;
      cout << "time spent in eval_h: " << t_eval_h_ << " s." << endl;
      cout << "time spent in main loop: " << t_mainloop_ << " s." << endl;
      cout << "time spent in callback function: " << t_callback_fun_ << " s." << endl;
      cout << "time spent in callback preparation: " << t_callback_prepare_ << " s." << endl;
    }
  
    stats_["t_eval_f"] = t_eval_f_;
    stats_["t_eval_grad_f"] = t_eval_grad_f_;
    stats_["t_eval_g"] = t_eval_g_;
    stats_["t_eval_jac_g"] = t_eval_jac_g_;
    stats_["t_eval_h"] = t_eval_h_;
    stats_["t_mainloop"] = t_mainloop_;
    stats_["t_callback_fun"] = t_callback_fun_;
    stats_["t_callback_prepare"] = t_callback_prepare_;
    
  }

  bool WorhpInternal::eval_h(const double* x, double obj_factor, const double* lambda, double* values){
    try{
      log("eval_h started");
      double time1 = clock();

      // Pass input
      H_tril_.setInput(x,NL_X);
      H_tril_.setInput(input(NLP_SOLVER_P),NL_P);
      H_tril_.setInput(obj_factor,NL_NUM_IN+NL_F);
      H_tril_.setInput(lambda,NL_NUM_IN+NL_G);

      // Evaluate
      H_tril_.evaluate();

      // Get results
      H_tril_.output().get(values);

      if(monitored("eval_h")){
	std::cout << "x = " <<  H_tril_.input() << std::endl;
	std::cout << "obj_factor= " << obj_factor << std::endl;
	std::cout << "lambda = " << H_tril_.input(1) << std::endl;

	// Pass input
	Hmod_.setInput(x,NL_X);
	Hmod_.setInput(input(NLP_SOLVER_P),NL_P);
        Hmod_.setInput(obj_factor,NL_NUM_IN+NL_F);
        Hmod_.setInput(lambda,NL_NUM_IN+NL_G);

	// Evaluate
	Hmod_.evaluate();

	std::cout << "H = " << Hmod_.output() << std::endl;

      }

      if (regularity_check_ && !isRegular(Hmod_.output().data())) casadi_error("WorhpInternal::eval_h: NaN or Inf detected.");
      
      double time2 = clock();
      t_eval_h_ += double(time2-time1)/CLOCKS_PER_SEC;
      log("eval_h ok");
      return true;
    } catch (exception& ex){
      cerr << "eval_h failed: " << ex.what() << endl;
      return false;
    }
  }

  bool WorhpInternal::eval_jac_g(const double* x,double* values){
    try{
      log("eval_jac_g started");
    
      // Quich finish if no constraints
      if(worhp_o.m==0){
	log("eval_jac_g quick return (m==0)");
	return true;
      }
    
      double time1 = clock();

      // Pass the argument to the function
      Jmod_.setInput(x,NL_X);
      Jmod_.setInput(input(NLP_SOLVER_P),NL_P);
    
      // Evaluate the function
      Jmod_.evaluate();

      // Get the output
      trans(Jmod_.output()).get(values);
    
      if(monitored("eval_jac_g")){
	cout << "x = " << Jmod_.input().data() << endl;
	cout << "J = " << endl;
	Jmod_.output().printSparse();
      }
    
      double time2 = clock();
      t_eval_jac_g_ += double(time2-time1)/CLOCKS_PER_SEC;
    
      log("eval_jac_g ok");
      return true;
    } catch (exception& ex){
      cerr << "eval_jac_g failed: " << ex.what() << endl;
      return false;
    }
  }

  bool WorhpInternal::eval_f(const double* x, double scale, double& obj_value)
  {
    try {
      log("eval_f started");
    
      // Log time
      double time1 = clock();

      // Pass the argument to the function
      nlpmod_.setInput(x);
      nlpmod_.setInput(input(NLP_SOLVER_P),NL_P);
      
      // Evaluate the function
      nlpmod_.evaluate();

      // Get the result
      nlpmod_.getOutput(obj_value,NL_F);

      // Printing
      if(monitored("eval_f")){
	cout << "x = " << nlpmod_.input(NL_X) << endl;
	cout << "obj_value = " << obj_value << endl;
      }
      obj_value *= scale;

      if (regularity_check_ && !isRegular(nlpmod_.output().data())) casadi_error("WorhpInternal::eval_f: NaN or Inf detected.");

      double time2 = clock();
      t_eval_f_ += double(time2-time1)/CLOCKS_PER_SEC;

      log("eval_f ok");
      return true;
    } catch (exception& ex){
      cerr << "eval_f failed: " << ex.what() << endl;
      return false;
    }
  }

  bool WorhpInternal::eval_g(const double* x, double* g)
  {
    try {
      log("eval_g started");
      double time1 = clock();

      if(worhp_o.m>0){
	// Pass the argument to the function
	nlpmod_.setInput(x,NL_X);
	nlpmod_.setInput(input(NLP_SOLVER_P),NL_P);

	// Evaluate the function and tape
	nlpmod_.evaluate();

	// Ge the result
	nlpmod_.getOutput(g,NL_G);

	// Printing
	if(monitored("eval_g")){
	  cout << "x = " << nlpmod_.input(NL_X) << endl;
	  cout << "g = " << nlpmod_.output(NL_G) << endl;
	}
      }

      if (regularity_check_ && !isRegular(nlpmod_.output(NL_G).data())) casadi_error("WorhpInternal::eval_g: NaN or Inf detected.");
    
      double time2 = clock();
      t_eval_g_ += double(time2-time1)/CLOCKS_PER_SEC;
    
      log("eval_g ok");
      return true;
    } catch (exception& ex){
      cerr << "eval_g failed: " << ex.what() << endl;
      return false;
    }
  }

  bool WorhpInternal::eval_grad_f(const double* x, double scale , double* grad_f )
  {
    try {
      log("eval_grad_f started");
      double time1 = clock();
    
      // Pass the argument to the function
      GFmod_.setInput(x,NL_X);
      GFmod_.setInput(input(NLP_SOLVER_P),NL_P);
      
      // Evaluate, adjoint mode
      GFmod_.evaluate();
      
      // Get the result
      GFmod_.output().get(grad_f,DENSE);

      // Scale
      for(int i=0; i<nx_; ++i){
	grad_f[i] *= scale;
      }
      
      // Printing
      if(monitored("eval_grad_f")){
	cout << "grad_f = " << GFmod_.output() << endl;
      }
      
      if (regularity_check_ && !isRegular(GFmod_.output().data())) casadi_error("WorhpInternal::eval_grad_f: NaN or Inf detected.");
    
      double time2 = clock();
      t_eval_grad_f_ += double(time2-time1)/CLOCKS_PER_SEC;

      // Check the result for regularity
      for(int i=0; i<nx_; ++i){
        if(isnan(grad_f[i]) || isinf(grad_f[i])){
          log("eval_grad_f: result not regular");
          return false;
	}
      }

      log("eval_grad_f ok");
      return true;
    } catch (exception& ex){
      cerr << "eval_jac_f failed: " << ex.what() << endl;
      return false;
    }
  }

  void WorhpInternal::setOptionsFromFile(const std::string & file) {
    int status;
    char *cpy = new char[file.size()+1] ;
    strcpy(cpy, file.c_str());
    worhp_p.initialised = true;
    ReadParamsNoInit(&status, cpy, &worhp_p);
    delete cpy;
    setOption("AcceptTolFeas",worhp_p.AcceptTolFeas);
    setOption("AcceptTolOpti",worhp_p.AcceptTolOpti);
    setOption("ArmijoBeta",worhp_p.ArmijoBeta);
    setOption("ArmijoMaxAlpha",worhp_p.ArmijoMaxAlpha);
    setOption("ArmijoMinAlpha",worhp_p.ArmijoMinAlpha);
    setOption("ArmijoMinAlphaRec",worhp_p.ArmijoMinAlphaRec);
    setOption("ArmijoSigma",worhp_p.ArmijoSigma);
    setOption("BettsFactor",worhp_p.BettsFactor);
    setOption("BettsPoint",worhp_p.BettsPoint);
    setOption("BoundTolFac",worhp_p.BoundTolFac);
    setOption("CorStepBettsSum",worhp_p.CorStepBettsSum);
    setOption("CorStepConvio",worhp_p.CorStepConvio);
    setOption("CorStepConStop",worhp_p.CorStepConStop);
    setOption("CorStepPFactor",worhp_p.CorStepPFactor);
    setOption("CorStepPMax",worhp_p.CorStepPMax);
    setOption("CheckFJ",worhp_p.CheckFJ);
    setOption("CurvBCond",worhp_p.CurvBCond);
    setOption("CurvBFac",worhp_p.CurvBFac);
    setOption("CurvCond",worhp_p.CurvCond);
    setOption("CurvFac",worhp_p.CurvFac);
    setOption("CutLength",worhp_p.CutLength);
    setOption("FeasibleInitTol",worhp_p.FeasibleInitTol);
    setOption("FidifEps",worhp_p.FidifEps);
    setOption("FocusOnFeasFactor",worhp_p.FocusOnFeasFactor);
    setOption("Infty",worhp_p.Infty);
    setOption("InftyUnbounded",worhp_p.InftyUnbounded);
    setOption("LMestQPipComTol",worhp_p.LMestQPipComTol);
    setOption("LMestQPipResTol",worhp_p.LMestQPipResTol);
    setOption("LowPassAlphaF",worhp_p.LowPassAlphaF);
    setOption("LowPassAlphaG",worhp_p.LowPassAlphaG);
    setOption("LowPassAlphaMerit",worhp_p.LowPassAlphaMerit);
    setOption("Ma57PivotThresh",worhp_p.Ma57PivotThresh);
    setOption("MeritGradTol",worhp_p.MeritGradTol);
    setOption("PenUpdEpsKFac",worhp_p.PenUpdEpsKFac);
    setOption("PenUpdEpsBar",worhp_p.PenUpdEpsBar);
    setOption("PenUpdMaxDeltaK",worhp_p.PenUpdMaxDeltaK);
    setOption("PenUpdMaxFac",worhp_p.PenUpdMaxFac);
    setOption("PenUpdRBar",worhp_p.PenUpdRBar);
    setOption("PrecisionF",worhp_p.PrecisionF);
    setOption("PrecisionG",worhp_p.PrecisionG);
    setOption("QPscaleParam",worhp_p.QPscaleParam);
    setOption("RelaxMaxDelta",worhp_p.RelaxMaxDelta);
    setOption("RelaxMaxPen",worhp_p.RelaxMaxPen);
    setOption("RelaxRho",worhp_p.RelaxRho);
    setOption("RelaxStart",worhp_p.RelaxStart);
    setOption("ScaleFacObj",worhp_p.ScaleFacObj);
    setOption("ScaleFacQP",worhp_p.ScaleFacQP);
    setOption("StartBettsTau",worhp_p.StartBettsTau);
    setOption("Timeout",worhp_p.Timeout);
    setOption("TolComp",worhp_p.TolComp);
    setOption("TolFeas",worhp_p.TolFeas);
    setOption("TolOpti",worhp_p.TolOpti);
    setOption("TolWeakActive",worhp_p.TolWeakActive);
    setOption("TooBigCV",worhp_p.TooBigCV);
    setOption("TooBigKKT",worhp_p.TooBigKKT);
    setOption("eps",worhp_p.eps);
    setOption("IncreaseIWS",worhp_p.IncreaseIWS);
    setOption("IncreaseRWS",worhp_p.IncreaseRWS);
    setOption("FilterGammaCV",worhp_p.FilterGammaCV);
    setOption("FilterGammaF",worhp_p.FilterGammaF);
    setOption("GammaAlpha",worhp_p.GammaAlpha);
    setOption("IncBettsTau",worhp_p.IncBettsTau);
    setOption("IncBettsTauMore",worhp_p.IncBettsTauMore);
    setOption("MinBettsTau",worhp_p.MinBettsTau);
    setOption("ReduceBettsTau",worhp_p.ReduceBettsTau);
    setOption("SwitchingDelta",worhp_p.SwitchingDelta);
    setOption("SwitchingSF",worhp_p.SwitchingSF);
    setOption("SwitchingSCV",worhp_p.SwitchingSCV);
    setOption("BFGSmethod",worhp_p.BFGSmethod);
    setOption("BFGSrestart",worhp_p.BFGSrestart);
    setOption("BFGSmaxblockSize",worhp_p.BFGSmaxblockSize);
    setOption("BFGSminblockSize",worhp_p.BFGSminblockSize);
    setOption("CorStepMaxIter",worhp_p.CorStepMaxIter);
    setOption("CorStepMethod",worhp_p.CorStepMethod);
    setOption("CorStepMode",worhp_p.CorStepMode);
    setOption("GroupMethod",worhp_p.GroupMethod);
    setOption("LogLevel",worhp_p.LogLevel);
    setOption("LogResult",worhp_p.LogResult);
    setOption("MaxCalls",worhp_p.MaxCalls);
    setOption("MaxForce",worhp_p.MaxForce);
    setOption("MaxGPart",worhp_p.MaxGPart);
    setOption("MaxIter",worhp_p.MaxIter);
    setOption("MeritFunction",worhp_p.MeritFunction);
    setOption("NLPmethod",worhp_p.NLPmethod);
    setOption("NLPprint",worhp_p.NLPprint);
    setOption("PairMethod",worhp_p.PairMethod);
    setOption("PenUpdEpsKSequence",worhp_p.PenUpdEpsKSequence);
    setOption("UserHMstructure",worhp_p.UserHMstructure);
    setOption("MaxLScounter",worhp_p.MaxLScounter);
    setOption("RegStrategy",worhp_p.RegStrategy);
    setOption("AutoQPRecovery",worhp_p.AutoQPRecovery);
    setOption("CheckStructureDF",worhp_p.CheckStructureDF);
    setOption("CheckStructureDG",worhp_p.CheckStructureDG);
    setOption("CheckStructureHM",worhp_p.CheckStructureHM);
    setOption("CorStepRecoveryDX",worhp_p.CorStepRecoveryDX);
    setOption("FGtogether",worhp_p.FGtogether);
    setOption("FJandND",worhp_p.FJandND);
    setOption("FeasibleDual",worhp_p.FeasibleDual);
    setOption("FeasibleInit",worhp_p.FeasibleInit);
    setOption("FeasibleOnly",worhp_p.FeasibleOnly);
    setOption("FidifHM",worhp_p.FidifHM);
    setOption("FirstDifCentral",worhp_p.FirstDifCentral);
    setOption("FocusOnFeas",worhp_p.FocusOnFeas);
    setOption("InitialLMest",worhp_p.InitialLMest);
    setOption("KeepAcceptableSol",worhp_p.KeepAcceptableSol);
    setOption("LinMult",worhp_p.LinMult);
    setOption("LowPassFilter",worhp_p.LowPassFilter);
    setOption("MatrixCC",worhp_p.MatrixCC);
    setOption("MoreRelax",worhp_p.MoreRelax);
    setOption("QuadraticProblem",worhp_p.QuadraticProblem);
    setOption("RestUntilFeas",worhp_p.RestUntilFeas);
    setOption("ScaleConIter",worhp_p.ScaleConIter);
    setOption("ScaledFD",worhp_p.ScaledFD);
    setOption("ScaledKKT",worhp_p.ScaledKKT);
    setOption("ScaledObj",worhp_p.ScaledObj);
    setOption("ScaledQP",worhp_p.ScaledQP);
    setOption("TakeQPSol",worhp_p.TakeQPSol);
    setOption("TooBig",worhp_p.TooBig);
    setOption("UserDF",worhp_p.UserDF);
    setOption("UserDG",worhp_p.UserDG);
    setOption("UserHM",worhp_p.UserHM);
    setOption("WeakActiveSet",worhp_p.WeakActiveSet);
    setOption("AlphaMinConst",worhp_p.AlphaMinConst);
    setOption("IgnoreFilterCrit",worhp_p.IgnoreFilterCrit);
    setOption("FilterBisecAlpha",worhp_p.FilterBisecAlpha);
    setOption("FilterIntersecAlpha",worhp_p.FilterIntersecAlpha);
    setOption("MaxNorm",worhp_p.MaxNorm);
    setOption("ReinitFilter",worhp_p.ReinitFilter);
    setOption("DebugMarker06",worhp_p.DebugMarker06);
    setOption("initialised",worhp_p.initialised);
    
    setOption("qp_ipBarrier",worhp_p.qp.ipBarrier);
    setOption("qp_ipComTol",worhp_p.qp.ipComTol);
    setOption("qp_ipFracBound",worhp_p.qp.ipFracBound);
    setOptionByEnumValue("qp_ipLsMethod",worhp_p.qp.ipLsMethod );
    setOption("qp_ipMinAlpha",worhp_p.qp.ipMinAlpha);
    setOption("qp_ipTryRelax",worhp_p.qp.ipTryRelax);
    setOption("qp_ipRelaxDiv",worhp_p.qp.ipRelaxDiv);
    setOption("qp_ipRelaxMult",worhp_p.qp.ipRelaxMult);
    setOption("qp_ipRelaxMax",worhp_p.qp.ipRelaxMax);
    setOption("qp_ipRelaxMin",worhp_p.qp.ipRelaxMin);
    setOption("qp_ipResTol",worhp_p.qp.ipResTol);
    setOption("qp_lsItMaxIter",worhp_p.qp.lsItMaxIter);
    setOptionByEnumValue("qp_lsItMethod",worhp_p.qp.lsItMethod );
    setOptionByEnumValue("qp_lsItPrecondMethod",worhp_p.qp.lsItPrecondMethod );
    setOption("qp_lsRefineMaxIter",worhp_p.qp.lsRefineMaxIter);
    setOption("qp_lsScale",worhp_p.qp.lsScale);
    setOption("qp_lsTrySimple",worhp_p.qp.lsTrySimple);
    setOption("qp_lsTol",worhp_p.qp.lsTol);
    setOption("qp_maxIter",worhp_p.qp.maxIter);
    setOptionByEnumValue("qp_method",worhp_p.qp.method );
    setOption("qp_nsnBeta",worhp_p.qp.nsnBeta);
    setOption("qp_nsnGradStep",worhp_p.qp.nsnGradStep);
    setOption("qp_nsnKKT",worhp_p.qp.nsnKKT);
    setOptionByEnumValue("qp_nsnLsMethod",worhp_p.qp.nsnLsMethod );
    setOption("qp_nsnMinAlpha",worhp_p.qp.nsnMinAlpha);
    setOption("qp_nsnSigma",worhp_p.qp.nsnSigma);
    setOptionByEnumValue("qp_printLevel",worhp_p.qp.printLevel );
    setOption("qp_scaleIntern",worhp_p.qp.scaleIntern);
    setOption("qp_strict",worhp_p.qp.strict);
      
    std::cout << "readparams status: " << status << std::endl;
  }


} // namespace CasADi
