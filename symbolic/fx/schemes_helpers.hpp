/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010 by Joel Andersson, Moritz Diehl, K.U.Leuven. All rights reserved.
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

/** All edits to this file will be lost - autogenerated by misc/autogencode.py */
#ifndef SCHEMES_HELPERS_HPP
#define SCHEMES_HELPERS_HPP
#include <vector>
#include <string>
#include <utility>
#include <map>
#include "io_scheme_vector.hpp"
namespace CasADi{ 

/// Helper function for 'ACADO_Input'

template<class M>
class ACADO_InputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit ACADO_InputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_ACADO_Input){} 
};
/// Input arguments of an ACADO OCP solver
/// 
/// \copydoc scheme_ACADO_Input
template<class M>
ACADO_InputIOSchemeVector<M> acadoIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M(),const std::string arg_s6="",M arg_m6=M(),const std::string arg_s7="",M arg_m7=M(),const std::string arg_s8="",M arg_m8=M(),const std::string arg_s9="",M arg_m9=M(),const std::string arg_s10="",M arg_m10=M(),const std::string arg_s11="",M arg_m11=M(),const std::string arg_s12="",M arg_m12=M(),const std::string arg_s13="",M arg_m13=M(),const std::string arg_s14="",M arg_m14=M(),const std::string arg_s15="",M arg_m15=M(),const std::string arg_s16="",M arg_m16=M()){
  std::vector<M> ret(17);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  if (arg_s6!="") arg.insert(make_pair(arg_s6,arg_m6));
  if (arg_s7!="") arg.insert(make_pair(arg_s7,arg_m7));
  if (arg_s8!="") arg.insert(make_pair(arg_s8,arg_m8));
  if (arg_s9!="") arg.insert(make_pair(arg_s9,arg_m9));
  if (arg_s10!="") arg.insert(make_pair(arg_s10,arg_m10));
  if (arg_s11!="") arg.insert(make_pair(arg_s11,arg_m11));
  if (arg_s12!="") arg.insert(make_pair(arg_s12,arg_m12));
  if (arg_s13!="") arg.insert(make_pair(arg_s13,arg_m13));
  if (arg_s14!="") arg.insert(make_pair(arg_s14,arg_m14));
  if (arg_s15!="") arg.insert(make_pair(arg_s15,arg_m15));
  if (arg_s16!="") arg.insert(make_pair(arg_s16,arg_m16));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_ACADO_Input,it->first);
    if (n==-1)
      casadi_error("Keyword error in ACADO_Input: '" << it->first << "' is not recognized. Available keywords are: x_guess, u_guess, p_guess, lbx, ubx, lbx0, ubx0, lbxf, ubxf, lbu, ubu, lbp, ubp, lbc, ubc, lbr, ubr");
    ret[n] = it->second;
  }
  return ACADO_InputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> acadoIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5="",const std::string arg_s6="",const std::string arg_s7="",const std::string arg_s8="",const std::string arg_s9="",const std::string arg_s10="",const std::string arg_s11="",const std::string arg_s12="",const std::string arg_s13="",const std::string arg_s14="",const std::string arg_s15="",const std::string arg_s16=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s5)));
  if (arg_s6!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s6)));
  if (arg_s7!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s7)));
  if (arg_s8!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s8)));
  if (arg_s9!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s9)));
  if (arg_s10!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s10)));
  if (arg_s11!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s11)));
  if (arg_s12!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s12)));
  if (arg_s13!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s13)));
  if (arg_s14!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s14)));
  if (arg_s15!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s15)));
  if (arg_s16!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Input,arg_s16)));
  return ret;

}
/// Helper function for 'ACADO_Output'

template<class M>
class ACADO_OutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit ACADO_OutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_ACADO_Output){} 
};
/// Output arguments of an ACADO OCP solver
/// 
/// \copydoc scheme_ACADO_Output
template<class M>
ACADO_OutputIOSchemeVector<M> acadoOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M()){
  std::vector<M> ret(4);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_ACADO_Output,it->first);
    if (n==-1)
      casadi_error("Keyword error in ACADO_Output: '" << it->first << "' is not recognized. Available keywords are: x_opt, u_opt, p_opt, cost");
    ret[n] = it->second;
  }
  return ACADO_OutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> acadoOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Output,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Output,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Output,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_Output,arg_s3)));
  return ret;

}
/// Helper function for 'ACADO_FCN_Input'

template<class M>
class ACADO_FCN_InputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit ACADO_FCN_InputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_ACADO_FCN_Input){} 
};
/// Input arguments of an ACADO function
/// 
/// \copydoc scheme_ACADO_FCN_Input
template<class M>
ACADO_FCN_InputIOSchemeVector<M> acadofcnIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M()){
  std::vector<M> ret(6);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_ACADO_FCN_Input,it->first);
    if (n==-1)
      casadi_error("Keyword error in ACADO_FCN_Input: '" << it->first << "' is not recognized. Available keywords are: t, xd, xa, u, p, xdot");
    ret[n] = it->second;
  }
  return ACADO_FCN_InputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> acadofcnIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_FCN_Input,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_FCN_Input,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_FCN_Input,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_FCN_Input,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_FCN_Input,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ACADO_FCN_Input,arg_s5)));
  return ret;

}
/// Helper function for 'ControlledDAEInput'

template<class M>
class ControlledDAEInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit ControlledDAEInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_ControlledDAEInput){} 
};
/// Input arguments of an ODE/DAE function
/// 
/// \copydoc scheme_ControlledDAEInput
template<class M>
ControlledDAEInputIOSchemeVector<M> controldaeIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M(),const std::string arg_s6="",M arg_m6=M(),const std::string arg_s7="",M arg_m7=M(),const std::string arg_s8="",M arg_m8=M()){
  std::vector<M> ret(9);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  if (arg_s6!="") arg.insert(make_pair(arg_s6,arg_m6));
  if (arg_s7!="") arg.insert(make_pair(arg_s7,arg_m7));
  if (arg_s8!="") arg.insert(make_pair(arg_s8,arg_m8));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_ControlledDAEInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in ControlledDAEInput: '" << it->first << "' is not recognized. Available keywords are: t, x, z, p, u, u_interp, x_major, t0, tf");
    ret[n] = it->second;
  }
  return ControlledDAEInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> controldaeIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5="",const std::string arg_s6="",const std::string arg_s7="",const std::string arg_s8=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlledDAEInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlledDAEInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlledDAEInput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlledDAEInput,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlledDAEInput,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlledDAEInput,arg_s5)));
  if (arg_s6!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlledDAEInput,arg_s6)));
  if (arg_s7!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlledDAEInput,arg_s7)));
  if (arg_s8!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlledDAEInput,arg_s8)));
  return ret;

}
/// Helper function for 'ControlSimulatorInput'

template<class M>
class ControlSimulatorInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit ControlSimulatorInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_ControlSimulatorInput){} 
};
/// Input arguments of a control simulator
/// 
/// \copydoc scheme_ControlSimulatorInput
template<class M>
ControlSimulatorInputIOSchemeVector<M> controlsimulatorIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M()){
  std::vector<M> ret(3);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_ControlSimulatorInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in ControlSimulatorInput: '" << it->first << "' is not recognized. Available keywords are: x0, p, u");
    ret[n] = it->second;
  }
  return ControlSimulatorInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> controlsimulatorIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlSimulatorInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlSimulatorInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_ControlSimulatorInput,arg_s2)));
  return ret;

}
/// Helper function for 'DAEInput'

template<class M>
class DAEInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit DAEInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_DAEInput){} 
};
/// Input arguments of an ODE/DAE function
/// 
/// \copydoc scheme_DAEInput
template<class M>
DAEInputIOSchemeVector<M> daeIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M()){
  std::vector<M> ret(4);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_DAEInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in DAEInput: '" << it->first << "' is not recognized. Available keywords are: x, z, p, t");
    ret[n] = it->second;
  }
  return DAEInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> daeIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_DAEInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_DAEInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_DAEInput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_DAEInput,arg_s3)));
  return ret;

}
/// Helper function for 'DAEOutput'

template<class M>
class DAEOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit DAEOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_DAEOutput){} 
};
/// Output arguments of an DAE function
/// 
/// \copydoc scheme_DAEOutput
template<class M>
DAEOutputIOSchemeVector<M> daeOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M()){
  std::vector<M> ret(3);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_DAEOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in DAEOutput: '" << it->first << "' is not recognized. Available keywords are: ode, alg, quad");
    ret[n] = it->second;
  }
  return DAEOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> daeOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_DAEOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_DAEOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_DAEOutput,arg_s2)));
  return ret;

}
/// Helper function for 'RDAEInput'

template<class M>
class RDAEInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit RDAEInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_RDAEInput){} 
};
/// Input arguments of an ODE/DAE backward integration function
/// 
/// \copydoc scheme_RDAEInput
template<class M>
RDAEInputIOSchemeVector<M> rdaeIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M(),const std::string arg_s6="",M arg_m6=M()){
  std::vector<M> ret(7);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  if (arg_s6!="") arg.insert(make_pair(arg_s6,arg_m6));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_RDAEInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in RDAEInput: '" << it->first << "' is not recognized. Available keywords are: rx, rz, rp, x, z, p, t");
    ret[n] = it->second;
  }
  return RDAEInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> rdaeIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5="",const std::string arg_s6=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_RDAEInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_RDAEInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_RDAEInput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_RDAEInput,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_RDAEInput,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_RDAEInput,arg_s5)));
  if (arg_s6!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_RDAEInput,arg_s6)));
  return ret;

}
/// Helper function for 'RDAEOutput'

template<class M>
class RDAEOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit RDAEOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_RDAEOutput){} 
};
/// Output arguments of an ODE/DAE backward integration function
/// 
/// \copydoc scheme_RDAEOutput
template<class M>
RDAEOutputIOSchemeVector<M> rdaeOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M()){
  std::vector<M> ret(3);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_RDAEOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in RDAEOutput: '" << it->first << "' is not recognized. Available keywords are: ode, alg, quad");
    ret[n] = it->second;
  }
  return RDAEOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> rdaeOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_RDAEOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_RDAEOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_RDAEOutput,arg_s2)));
  return ret;

}
/// Helper function for 'IntegratorInput'

template<class M>
class IntegratorInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit IntegratorInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_IntegratorInput){} 
};
/// Input arguments of an integrator
/// 
/// \copydoc scheme_IntegratorInput
template<class M>
IntegratorInputIOSchemeVector<M> integratorIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M()){
  std::vector<M> ret(4);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_IntegratorInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in IntegratorInput: '" << it->first << "' is not recognized. Available keywords are: x0, p, rx0, rp");
    ret[n] = it->second;
  }
  return IntegratorInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> integratorIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_IntegratorInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_IntegratorInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_IntegratorInput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_IntegratorInput,arg_s3)));
  return ret;

}
/// Helper function for 'IntegratorOutput'

template<class M>
class IntegratorOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit IntegratorOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_IntegratorOutput){} 
};
/// Output arguments of an integrator
/// 
/// \copydoc scheme_IntegratorOutput
template<class M>
IntegratorOutputIOSchemeVector<M> integratorOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M()){
  std::vector<M> ret(4);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_IntegratorOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in IntegratorOutput: '" << it->first << "' is not recognized. Available keywords are: xf, qf, rxf, rqf");
    ret[n] = it->second;
  }
  return IntegratorOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> integratorOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_IntegratorOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_IntegratorOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_IntegratorOutput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_IntegratorOutput,arg_s3)));
  return ret;

}
/// Helper function for 'LPSolverInput'

template<class M>
class LPSolverInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit LPSolverInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_LPSolverInput){} 
};
/// Input arguments of a LP problem
/// 
/// \copydoc scheme_LPSolverInput
template<class M>
LPSolverInputIOSchemeVector<M> lpIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M()){
  std::vector<M> ret(6);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LPSolverInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in LPSolverInput: '" << it->first << "' is not recognized. Available keywords are: c, a, lba, uba, lbx, ubx");
    ret[n] = it->second;
  }
  return LPSolverInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> lpIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_LPSolverInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_LPSolverInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_LPSolverInput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_LPSolverInput,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_LPSolverInput,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_LPSolverInput,arg_s5)));
  return ret;

}
/// Helper function for 'LPSolverOutput'

template<class M>
class LPSolverOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit LPSolverOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_LPSolverOutput){} 
};
/// Output arguments of an LP Solver
/// 
/// \copydoc scheme_LPSolverOutput
template<class M>
LPSolverOutputIOSchemeVector<M> lpOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M()){
  std::vector<M> ret(4);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LPSolverOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in LPSolverOutput: '" << it->first << "' is not recognized. Available keywords are: x, cost, lam_a, lam_x");
    ret[n] = it->second;
  }
  return LPSolverOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> lpOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_LPSolverOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_LPSolverOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_LPSolverOutput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_LPSolverOutput,arg_s3)));
  return ret;

}
/// Helper function for 'LPStruct'

template<class M>
class LPStructIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit LPStructIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_LPStruct){} 
};
/// Structure specification of an LP
/// 
/// \copydoc scheme_LPStruct
template<class M>
LPStructIOSchemeVector<M> lpStruct(const std::string arg_s0="",M arg_m0=M()){
  std::vector<M> ret(1);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LPStruct,it->first);
    if (n==-1)
      casadi_error("Keyword error in LPStruct: '" << it->first << "' is not recognized. Available keywords are: a");
    ret[n] = it->second;
  }
  return LPStructIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> lpStruct(const std::vector<M>& args,const std::string arg_s0=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_LPStruct,arg_s0)));
  return ret;

}
/// Helper function for 'NLPInput'

template<class M>
class NLPInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit NLPInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_NLPInput){} 
};
/// Input arguments of an NLP function
/// 
/// \copydoc scheme_NLPInput
template<class M>
NLPInputIOSchemeVector<M> nlpIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M()){
  std::vector<M> ret(2);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_NLPInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in NLPInput: '" << it->first << "' is not recognized. Available keywords are: x, p");
    ret[n] = it->second;
  }
  return NLPInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> nlpIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPInput,arg_s1)));
  return ret;

}
/// Helper function for 'NLPOutput'

template<class M>
class NLPOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit NLPOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_NLPOutput){} 
};
/// Output arguments of an NLP function
/// 
/// \copydoc scheme_NLPOutput
template<class M>
NLPOutputIOSchemeVector<M> nlpOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M()){
  std::vector<M> ret(2);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_NLPOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in NLPOutput: '" << it->first << "' is not recognized. Available keywords are: f, g");
    ret[n] = it->second;
  }
  return NLPOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> nlpOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPOutput,arg_s1)));
  return ret;

}
/// Helper function for 'GradFInput'

template<class M>
class GradFInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit GradFInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_GradFInput){} 
};
/// Input arguments of an NLP objective gradient function
/// 
/// \copydoc scheme_GradFInput
template<class M>
GradFInputIOSchemeVector<M> gradFIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M()){
  std::vector<M> ret(2);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_GradFInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in GradFInput: '" << it->first << "' is not recognized. Available keywords are: x, p");
    ret[n] = it->second;
  }
  return GradFInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> gradFIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_GradFInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_GradFInput,arg_s1)));
  return ret;

}
/// Helper function for 'GradFOutput'

template<class M>
class GradFOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit GradFOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_GradFOutput){} 
};
/// Output arguments of an NLP objective gradient function
/// 
/// \copydoc scheme_GradFOutput
template<class M>
GradFOutputIOSchemeVector<M> gradFOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M()){
  std::vector<M> ret(3);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_GradFOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in GradFOutput: '" << it->first << "' is not recognized. Available keywords are: grad, f, g");
    ret[n] = it->second;
  }
  return GradFOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> gradFOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_GradFOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_GradFOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_GradFOutput,arg_s2)));
  return ret;

}
/// Helper function for 'JacGInput'

template<class M>
class JacGInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit JacGInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_JacGInput){} 
};
/// Input arguments of an NLP Jacobian function
/// 
/// \copydoc scheme_JacGInput
template<class M>
JacGInputIOSchemeVector<M> jacGIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M()){
  std::vector<M> ret(2);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_JacGInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in JacGInput: '" << it->first << "' is not recognized. Available keywords are: x, p");
    ret[n] = it->second;
  }
  return JacGInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> jacGIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_JacGInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_JacGInput,arg_s1)));
  return ret;

}
/// Helper function for 'JacGOutput'

template<class M>
class JacGOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit JacGOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_JacGOutput){} 
};
/// Output arguments of an NLP Jacobian function
/// 
/// \copydoc scheme_JacGOutput
template<class M>
JacGOutputIOSchemeVector<M> jacGOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M()){
  std::vector<M> ret(3);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_JacGOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in JacGOutput: '" << it->first << "' is not recognized. Available keywords are: jac, f, g");
    ret[n] = it->second;
  }
  return JacGOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> jacGOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_JacGOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_JacGOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_JacGOutput,arg_s2)));
  return ret;

}
/// Helper function for 'HessLagInput'

template<class M>
class HessLagInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit HessLagInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_HessLagInput){} 
};
/// Input arguments of an NLP Hessian function
/// 
/// \copydoc scheme_HessLagInput
template<class M>
HessLagInputIOSchemeVector<M> hessLagIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M()){
  std::vector<M> ret(4);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_HessLagInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in HessLagInput: '" << it->first << "' is not recognized. Available keywords are: x, p, lam_f, lam_g");
    ret[n] = it->second;
  }
  return HessLagInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> hessLagIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_HessLagInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_HessLagInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_HessLagInput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_HessLagInput,arg_s3)));
  return ret;

}
/// Helper function for 'HessLagOutput'

template<class M>
class HessLagOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit HessLagOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_HessLagOutput){} 
};
/// Output arguments of an NLP Hessian function
/// 
/// \copydoc scheme_HessLagOutput
template<class M>
HessLagOutputIOSchemeVector<M> hessLagOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M()){
  std::vector<M> ret(5);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_HessLagOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in HessLagOutput: '" << it->first << "' is not recognized. Available keywords are: hess, f, g, grad_x, grad_p");
    ret[n] = it->second;
  }
  return HessLagOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> hessLagOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_HessLagOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_HessLagOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_HessLagOutput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_HessLagOutput,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_HessLagOutput,arg_s4)));
  return ret;

}
/// Helper function for 'NLPSolverInput'

template<class M>
class NLPSolverInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit NLPSolverInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_NLPSolverInput){} 
};
/// Input arguments of an NLP Solver
/// 
/// \copydoc scheme_NLPSolverInput
template<class M>
NLPSolverInputIOSchemeVector<M> nlpSolverIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M(),const std::string arg_s6="",M arg_m6=M(),const std::string arg_s7="",M arg_m7=M()){
  std::vector<M> ret(8);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  if (arg_s6!="") arg.insert(make_pair(arg_s6,arg_m6));
  if (arg_s7!="") arg.insert(make_pair(arg_s7,arg_m7));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_NLPSolverInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in NLPSolverInput: '" << it->first << "' is not recognized. Available keywords are: x0, p, lbx, ubx, lbg, ubg, lam_x0, lam_g0");
    ret[n] = it->second;
  }
  return NLPSolverInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> nlpSolverIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5="",const std::string arg_s6="",const std::string arg_s7=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverInput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverInput,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverInput,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverInput,arg_s5)));
  if (arg_s6!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverInput,arg_s6)));
  if (arg_s7!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverInput,arg_s7)));
  return ret;

}
/// Helper function for 'NLPSolverOutput'

template<class M>
class NLPSolverOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit NLPSolverOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_NLPSolverOutput){} 
};
/// Output arguments of an NLP Solver
/// 
/// \copydoc scheme_NLPSolverOutput
template<class M>
NLPSolverOutputIOSchemeVector<M> nlpSolverOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M()){
  std::vector<M> ret(6);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_NLPSolverOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in NLPSolverOutput: '" << it->first << "' is not recognized. Available keywords are: x, f, g, lam_x, lam_g, lam_p");
    ret[n] = it->second;
  }
  return NLPSolverOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> nlpSolverOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverOutput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverOutput,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverOutput,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_NLPSolverOutput,arg_s5)));
  return ret;

}
/// Helper function for 'MayerInput'

template<class M>
class MayerInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit MayerInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_MayerInput){} 
};
/// Input arguments of a Mayer Term \n
/// nx: Number of states: from ffcn.input(INTEGRATOR_X0).size() \n
/// np: Number of parameters: from option number_of_parameters\n
/// 
/// \copydoc scheme_MayerInput
template<class M>
MayerInputIOSchemeVector<M> mayerIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M()){
  std::vector<M> ret(2);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_MayerInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in MayerInput: '" << it->first << "' is not recognized. Available keywords are: x, p");
    ret[n] = it->second;
  }
  return MayerInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> mayerIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_MayerInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_MayerInput,arg_s1)));
  return ret;

}
/// Helper function for 'OCPInput'

template<class M>
class OCPInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit OCPInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_OCPInput){} 
};
/// Input arguments of an OCP Solver \n
/// ns: Number of shooting nodes: from option number_of_grid_points\n
/// nx: Number of states: from ffcn.input(INTEGRATOR_X0).size() \n
/// nc: Number of constants duting intergation: ffcn.input(INTEGRATOR_P).size()
/// nu: Number of controls: from nc - np \n
/// np: Number of parameters: from option number_of_parameters\n
/// nh: Number of point constraints: from cfcn.input(0).size()
/// 
/// \copydoc scheme_OCPInput
template<class M>
OCPInputIOSchemeVector<M> ocpIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M(),const std::string arg_s6="",M arg_m6=M(),const std::string arg_s7="",M arg_m7=M(),const std::string arg_s8="",M arg_m8=M(),const std::string arg_s9="",M arg_m9=M(),const std::string arg_s10="",M arg_m10=M(),const std::string arg_s11="",M arg_m11=M(),const std::string arg_s12="",M arg_m12=M()){
  std::vector<M> ret(13);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  if (arg_s6!="") arg.insert(make_pair(arg_s6,arg_m6));
  if (arg_s7!="") arg.insert(make_pair(arg_s7,arg_m7));
  if (arg_s8!="") arg.insert(make_pair(arg_s8,arg_m8));
  if (arg_s9!="") arg.insert(make_pair(arg_s9,arg_m9));
  if (arg_s10!="") arg.insert(make_pair(arg_s10,arg_m10));
  if (arg_s11!="") arg.insert(make_pair(arg_s11,arg_m11));
  if (arg_s12!="") arg.insert(make_pair(arg_s12,arg_m12));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_OCPInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in OCPInput: '" << it->first << "' is not recognized. Available keywords are: lbx, ubx, x_init, lbu, ubu, u_init, lbp, ubp, p_init, lbh, ubh, lbg, ubg");
    ret[n] = it->second;
  }
  return OCPInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> ocpIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5="",const std::string arg_s6="",const std::string arg_s7="",const std::string arg_s8="",const std::string arg_s9="",const std::string arg_s10="",const std::string arg_s11="",const std::string arg_s12=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s5)));
  if (arg_s6!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s6)));
  if (arg_s7!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s7)));
  if (arg_s8!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s8)));
  if (arg_s9!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s9)));
  if (arg_s10!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s10)));
  if (arg_s11!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s11)));
  if (arg_s12!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPInput,arg_s12)));
  return ret;

}
/// Helper function for 'OCPOutput'

template<class M>
class OCPOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit OCPOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_OCPOutput){} 
};
/// Output arguments of an OCP Solver
/// 
/// \copydoc scheme_OCPOutput
template<class M>
OCPOutputIOSchemeVector<M> ocpOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M()){
  std::vector<M> ret(4);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_OCPOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in OCPOutput: '" << it->first << "' is not recognized. Available keywords are: x_opt, u_opt, p_opt, cost");
    ret[n] = it->second;
  }
  return OCPOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> ocpOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPOutput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_OCPOutput,arg_s3)));
  return ret;

}
/// Helper function for 'QPSolverInput'

template<class M>
class QPSolverInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit QPSolverInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_QPSolverInput){} 
};
/// Input arguments of a QP problem
/// 
/// \copydoc scheme_QPSolverInput
template<class M>
QPSolverInputIOSchemeVector<M> qpIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M(),const std::string arg_s6="",M arg_m6=M(),const std::string arg_s7="",M arg_m7=M(),const std::string arg_s8="",M arg_m8=M()){
  std::vector<M> ret(9);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  if (arg_s6!="") arg.insert(make_pair(arg_s6,arg_m6));
  if (arg_s7!="") arg.insert(make_pair(arg_s7,arg_m7));
  if (arg_s8!="") arg.insert(make_pair(arg_s8,arg_m8));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_QPSolverInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in QPSolverInput: '" << it->first << "' is not recognized. Available keywords are: h, g, a, lba, uba, lbx, ubx, x0, lam_x0");
    ret[n] = it->second;
  }
  return QPSolverInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> qpIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5="",const std::string arg_s6="",const std::string arg_s7="",const std::string arg_s8=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverInput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverInput,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverInput,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverInput,arg_s5)));
  if (arg_s6!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverInput,arg_s6)));
  if (arg_s7!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverInput,arg_s7)));
  if (arg_s8!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverInput,arg_s8)));
  return ret;

}
/// Helper function for 'QPSolverOutput'

template<class M>
class QPSolverOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit QPSolverOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_QPSolverOutput){} 
};
/// Output arguments of an QP Solver
/// 
/// \copydoc scheme_QPSolverOutput
template<class M>
QPSolverOutputIOSchemeVector<M> qpOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M()){
  std::vector<M> ret(4);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_QPSolverOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in QPSolverOutput: '" << it->first << "' is not recognized. Available keywords are: x, cost, lam_a, lam_x");
    ret[n] = it->second;
  }
  return QPSolverOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> qpOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverOutput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPSolverOutput,arg_s3)));
  return ret;

}
/// Helper function for 'QPStruct'

template<class M>
class QPStructIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit QPStructIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_QPStruct){} 
};
/// Structure specification of a QP
/// 
/// \copydoc scheme_QPStruct
template<class M>
QPStructIOSchemeVector<M> qpStruct(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M()){
  std::vector<M> ret(2);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_QPStruct,it->first);
    if (n==-1)
      casadi_error("Keyword error in QPStruct: '" << it->first << "' is not recognized. Available keywords are: h, a");
    ret[n] = it->second;
  }
  return QPStructIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> qpStruct(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPStruct,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_QPStruct,arg_s1)));
  return ret;

}
/// Helper function for 'SDPInput'

template<class M>
class SDPInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit SDPInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_SDPInput){} 
};
/// Input arguments of a SDP problem
/// 
/// \copydoc scheme_SDPInput
template<class M>
SDPInputIOSchemeVector<M> sdpIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M(),const std::string arg_s6="",M arg_m6=M(),const std::string arg_s7="",M arg_m7=M()){
  std::vector<M> ret(8);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  if (arg_s6!="") arg.insert(make_pair(arg_s6,arg_m6));
  if (arg_s7!="") arg.insert(make_pair(arg_s7,arg_m7));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SDPInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in SDPInput: '" << it->first << "' is not recognized. Available keywords are: f, c, g, a, lba, uba, lbx, ubx");
    ret[n] = it->second;
  }
  return SDPInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> sdpIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5="",const std::string arg_s6="",const std::string arg_s7=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPInput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPInput,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPInput,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPInput,arg_s5)));
  if (arg_s6!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPInput,arg_s6)));
  if (arg_s7!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPInput,arg_s7)));
  return ret;

}
/// Helper function for 'SDPOutput'

template<class M>
class SDPOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit SDPOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_SDPOutput){} 
};
/// Output arguments of an SDP Solver
/// 
/// \copydoc scheme_SDPOutput
template<class M>
SDPOutputIOSchemeVector<M> sdpOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M(),const std::string arg_s6="",M arg_m6=M()){
  std::vector<M> ret(7);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  if (arg_s6!="") arg.insert(make_pair(arg_s6,arg_m6));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SDPOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in SDPOutput: '" << it->first << "' is not recognized. Available keywords are: x, p, dual, cost, dual_cost, lam_a, lam_x");
    ret[n] = it->second;
  }
  return SDPOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> sdpOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5="",const std::string arg_s6=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPOutput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPOutput,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPOutput,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPOutput,arg_s5)));
  if (arg_s6!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPOutput,arg_s6)));
  return ret;

}
/// Helper function for 'SDPStruct'

template<class M>
class SDPStructIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit SDPStructIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_SDPStruct){} 
};
/// Structure specification of an SDP
/// 
/// \copydoc scheme_SDPStruct
template<class M>
SDPStructIOSchemeVector<M> sdpStruct(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M()){
  std::vector<M> ret(3);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SDPStruct,it->first);
    if (n==-1)
      casadi_error("Keyword error in SDPStruct: '" << it->first << "' is not recognized. Available keywords are: f, g, a");
    ret[n] = it->second;
  }
  return SDPStructIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> sdpStruct(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPStruct,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPStruct,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SDPStruct,arg_s2)));
  return ret;

}
/// Helper function for 'SOCPInput'

template<class M>
class SOCPInputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit SOCPInputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_SOCPInput){} 
};
/// Input arguments of a SOCP problem
/// 
/// \copydoc scheme_SOCPInput
template<class M>
SOCPInputIOSchemeVector<M> socpIn(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M(),const std::string arg_s4="",M arg_m4=M(),const std::string arg_s5="",M arg_m5=M(),const std::string arg_s6="",M arg_m6=M(),const std::string arg_s7="",M arg_m7=M(),const std::string arg_s8="",M arg_m8=M(),const std::string arg_s9="",M arg_m9=M()){
  std::vector<M> ret(10);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  if (arg_s4!="") arg.insert(make_pair(arg_s4,arg_m4));
  if (arg_s5!="") arg.insert(make_pair(arg_s5,arg_m5));
  if (arg_s6!="") arg.insert(make_pair(arg_s6,arg_m6));
  if (arg_s7!="") arg.insert(make_pair(arg_s7,arg_m7));
  if (arg_s8!="") arg.insert(make_pair(arg_s8,arg_m8));
  if (arg_s9!="") arg.insert(make_pair(arg_s9,arg_m9));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SOCPInput,it->first);
    if (n==-1)
      casadi_error("Keyword error in SOCPInput: '" << it->first << "' is not recognized. Available keywords are: g, h, e, f, c, a, lba, uba, lbx, ubx");
    ret[n] = it->second;
  }
  return SOCPInputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> socpIn(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3="",const std::string arg_s4="",const std::string arg_s5="",const std::string arg_s6="",const std::string arg_s7="",const std::string arg_s8="",const std::string arg_s9=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPInput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPInput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPInput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPInput,arg_s3)));
  if (arg_s4!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPInput,arg_s4)));
  if (arg_s5!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPInput,arg_s5)));
  if (arg_s6!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPInput,arg_s6)));
  if (arg_s7!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPInput,arg_s7)));
  if (arg_s8!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPInput,arg_s8)));
  if (arg_s9!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPInput,arg_s9)));
  return ret;

}
/// Helper function for 'SOCPOutput'

template<class M>
class SOCPOutputIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit SOCPOutputIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_SOCPOutput){} 
};
/// Output arguments of an SOCP Solver
/// 
/// \copydoc scheme_SOCPOutput
template<class M>
SOCPOutputIOSchemeVector<M> socpOut(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M(),const std::string arg_s2="",M arg_m2=M(),const std::string arg_s3="",M arg_m3=M()){
  std::vector<M> ret(4);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  if (arg_s2!="") arg.insert(make_pair(arg_s2,arg_m2));
  if (arg_s3!="") arg.insert(make_pair(arg_s3,arg_m3));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SOCPOutput,it->first);
    if (n==-1)
      casadi_error("Keyword error in SOCPOutput: '" << it->first << "' is not recognized. Available keywords are: x, cost, lam_a, lam_x");
    ret[n] = it->second;
  }
  return SOCPOutputIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> socpOut(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1="",const std::string arg_s2="",const std::string arg_s3=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPOutput,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPOutput,arg_s1)));
  if (arg_s2!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPOutput,arg_s2)));
  if (arg_s3!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPOutput,arg_s3)));
  return ret;

}
/// Helper function for 'SOCPStruct'

template<class M>
class SOCPStructIOSchemeVector : public IOSchemeVector<M> {
  public:
    explicit SOCPStructIOSchemeVector(const std::vector<M>& t) : IOSchemeVector<M>(t,SCHEME_SOCPStruct){} 
};
/// Structure specification of an SOCP
/// 
/// \copydoc scheme_SOCPStruct
template<class M>
SOCPStructIOSchemeVector<M> socpStruct(const std::string arg_s0="",M arg_m0=M(),const std::string arg_s1="",M arg_m1=M()){
  std::vector<M> ret(2);
  std::map<std::string,M> arg;
  if (arg_s0!="") arg.insert(make_pair(arg_s0,arg_m0));
  if (arg_s1!="") arg.insert(make_pair(arg_s1,arg_m1));
  typedef typename std::map<std::string,M>::const_iterator it_type;
  for(it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SOCPStruct,it->first);
    if (n==-1)
      casadi_error("Keyword error in SOCPStruct: '" << it->first << "' is not recognized. Available keywords are: g, a");
    ret[n] = it->second;
  }
  return SOCPStructIOSchemeVector<M>(ret);
}
template<class M>
std::vector<M> socpStruct(const std::vector<M>& args,const std::string arg_s0="",const std::string arg_s1=""){
  std::vector<M> ret;
  if (arg_s0!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPStruct,arg_s0)));
  if (arg_s1!="") ret.push_back(args.at(getSchemeEntryEnum(SCHEME_SOCPStruct,arg_s1)));
  return ret;

}
}
#endif //SCHEMES_HELPERS_HPP

