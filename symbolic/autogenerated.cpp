/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010 by Joel Andersson, Moritz Diehl, K.U.Leuven. All rights reserved.
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

/** All edits to this file will be lost - autogenerated by misc/autogencode.py */
#include "autogenerated.hpp"
#include <string>
namespace CasADi{

std::string describeInput(InputOutputScheme scheme, int i) {
  std::stringstream ss;
  ss << "Input argument #" << i;
  if (scheme!=SCHEME_unknown) {
    ss << " (" << getSchemeEntryEnumName(scheme,i) <<  " aka '" << getSchemeEntryName(scheme,i) << "')";
  }
  return ss.str();
}

std::string describeOutput(InputOutputScheme scheme, int i) {
  std::stringstream ss;
  ss << "Output argument #" << i;
  if (scheme!=SCHEME_unknown) {
    ss << " (" << getSchemeEntryEnumName(scheme,i) <<  " aka '" << getSchemeEntryName(scheme,i) << "')";
  }
  return ss.str();
}
std::string getSchemeName(InputOutputScheme scheme) {
  switch (scheme) {
    case SCHEME_ACADO_Input: return "ACADO_Input";
    case SCHEME_ACADO_Output: return "ACADO_Output";
    case SCHEME_ACADO_FCN_Input: return "ACADO_FCN_Input";
    case SCHEME_ControlledDAEInput: return "ControlledDAEInput";
    case SCHEME_ControlSimulatorInput: return "ControlSimulatorInput";
    case SCHEME_DAEInput: return "DAEInput";
    case SCHEME_DAEOutput: return "DAEOutput";
    case SCHEME_RDAEInput: return "RDAEInput";
    case SCHEME_RDAEOutput: return "RDAEOutput";
    case SCHEME_IntegratorInput: return "IntegratorInput";
    case SCHEME_IntegratorOutput: return "IntegratorOutput";
    case SCHEME_NLPInput: return "NLPInput";
    case SCHEME_NLPOutput: return "NLPOutput";
    case SCHEME_GradFInput: return "GradFInput";
    case SCHEME_GradFOutput: return "GradFOutput";
    case SCHEME_JacGInput: return "JacGInput";
    case SCHEME_JacGOutput: return "JacGOutput";
    case SCHEME_HessLagInput: return "HessLagInput";
    case SCHEME_HessLagOutput: return "HessLagOutput";
    case SCHEME_NLPSolverInput: return "NLPSolverInput";
    case SCHEME_NLPSolverOutput: return "NLPSolverOutput";
    case SCHEME_MayerInput: return "MayerInput";
    case SCHEME_OCPInput: return "OCPInput";
    case SCHEME_OCPOutput: return "OCPOutput";
    case SCHEME_QPInput: return "QPInput";
    case SCHEME_QPOutput: return "QPOutput";
    case SCHEME_SDPInput: return "SDPInput";
    case SCHEME_SDPOutput: return "SDPOutput";
    case SCHEME_unknown: return "unknown";
  }
}
std::string getSchemeEntryNames(InputOutputScheme scheme) {
  switch (scheme) {
    case SCHEME_ACADO_Input: return "x_guess, u_guess, p_guess, lbx, ubx, lbx0, ubx0, lbxf, ubxf, lbu, ubu, lbp, ubp, lbc, ubc, lbr, ubr";
    case SCHEME_ACADO_Output: return "x_opt, u_opt, p_opt, cost";
    case SCHEME_ACADO_FCN_Input: return "t, xd, xa, u, p, xdot";
    case SCHEME_ControlledDAEInput: return "t, x, z, p, u, u_interp, x_major, t0, tf";
    case SCHEME_ControlSimulatorInput: return "x0, p, u";
    case SCHEME_DAEInput: return "x, z, p, t";
    case SCHEME_DAEOutput: return "ode, alg, quad";
    case SCHEME_RDAEInput: return "rx, rz, rp, x, z, p, t";
    case SCHEME_RDAEOutput: return "ode, alg, quad";
    case SCHEME_IntegratorInput: return "x0, p, rx0, rp";
    case SCHEME_IntegratorOutput: return "xf, qf, rxf, rqf";
    case SCHEME_NLPInput: return "x, p";
    case SCHEME_NLPOutput: return "f, g";
    case SCHEME_GradFInput: return "x, p";
    case SCHEME_GradFOutput: return "grad, f, g";
    case SCHEME_JacGInput: return "x, p";
    case SCHEME_JacGOutput: return "jac, f, g";
    case SCHEME_HessLagInput: return "x, p, lam_f, lam_g";
    case SCHEME_HessLagOutput: return "hess, f, g, grad_x, grad_p";
    case SCHEME_NLPSolverInput: return "x0, p, lbx, ubx, lbg, ubg, lam_x0, lam_g0";
    case SCHEME_NLPSolverOutput: return "x, f, g, lam_x, lam_g, lam_p";
    case SCHEME_MayerInput: return "x, p";
    case SCHEME_OCPInput: return "lbx, ubx, x_init, lbu, ubu, u_init, lbp, ubp, p_init, lbh, ubh, lbg, ubg";
    case SCHEME_OCPOutput: return "x_opt, u_opt, p_opt, cost";
    case SCHEME_QPInput: return "h, g, a, lba, uba, lbx, ubx, x_init, lambda_init";
    case SCHEME_QPOutput: return "primal, cost, lambda_a, lambda_x";
    case SCHEME_SDPInput: return "a, b, c";
    case SCHEME_SDPOutput: return "primal, p, dual, primal_cost, dual_cost";
    case SCHEME_unknown: return "not available";
  }
}
std::string getSchemeEntryName(InputOutputScheme scheme, int i) {
  switch (scheme) {
    case SCHEME_ACADO_Input: 
      if(i==0) return "x_guess";
      if(i==1) return "u_guess";
      if(i==2) return "p_guess";
      if(i==3) return "lbx";
      if(i==4) return "ubx";
      if(i==5) return "lbx0";
      if(i==6) return "ubx0";
      if(i==7) return "lbxf";
      if(i==8) return "ubxf";
      if(i==9) return "lbu";
      if(i==10) return "ubu";
      if(i==11) return "lbp";
      if(i==12) return "ubp";
      if(i==13) return "lbc";
      if(i==14) return "ubc";
      if(i==15) return "lbr";
      if(i==16) return "ubr";
      break;
    case SCHEME_ACADO_Output: 
      if(i==0) return "x_opt";
      if(i==1) return "u_opt";
      if(i==2) return "p_opt";
      if(i==3) return "cost";
      break;
    case SCHEME_ACADO_FCN_Input: 
      if(i==0) return "t";
      if(i==1) return "xd";
      if(i==2) return "xa";
      if(i==3) return "u";
      if(i==4) return "p";
      if(i==5) return "xdot";
      break;
    case SCHEME_ControlledDAEInput: 
      if(i==0) return "t";
      if(i==1) return "x";
      if(i==2) return "z";
      if(i==3) return "p";
      if(i==4) return "u";
      if(i==5) return "u_interp";
      if(i==6) return "x_major";
      if(i==7) return "t0";
      if(i==8) return "tf";
      break;
    case SCHEME_ControlSimulatorInput: 
      if(i==0) return "x0";
      if(i==1) return "p";
      if(i==2) return "u";
      break;
    case SCHEME_DAEInput: 
      if(i==0) return "x";
      if(i==1) return "z";
      if(i==2) return "p";
      if(i==3) return "t";
      break;
    case SCHEME_DAEOutput: 
      if(i==0) return "ode";
      if(i==1) return "alg";
      if(i==2) return "quad";
      break;
    case SCHEME_RDAEInput: 
      if(i==0) return "rx";
      if(i==1) return "rz";
      if(i==2) return "rp";
      if(i==3) return "x";
      if(i==4) return "z";
      if(i==5) return "p";
      if(i==6) return "t";
      break;
    case SCHEME_RDAEOutput: 
      if(i==0) return "ode";
      if(i==1) return "alg";
      if(i==2) return "quad";
      break;
    case SCHEME_IntegratorInput: 
      if(i==0) return "x0";
      if(i==1) return "p";
      if(i==2) return "rx0";
      if(i==3) return "rp";
      break;
    case SCHEME_IntegratorOutput: 
      if(i==0) return "xf";
      if(i==1) return "qf";
      if(i==2) return "rxf";
      if(i==3) return "rqf";
      break;
    case SCHEME_NLPInput: 
      if(i==0) return "x";
      if(i==1) return "p";
      break;
    case SCHEME_NLPOutput: 
      if(i==0) return "f";
      if(i==1) return "g";
      break;
    case SCHEME_GradFInput: 
      if(i==0) return "x";
      if(i==1) return "p";
      break;
    case SCHEME_GradFOutput: 
      if(i==0) return "grad";
      if(i==1) return "f";
      if(i==2) return "g";
      break;
    case SCHEME_JacGInput: 
      if(i==0) return "x";
      if(i==1) return "p";
      break;
    case SCHEME_JacGOutput: 
      if(i==0) return "jac";
      if(i==1) return "f";
      if(i==2) return "g";
      break;
    case SCHEME_HessLagInput: 
      if(i==0) return "x";
      if(i==1) return "p";
      if(i==2) return "lam_f";
      if(i==3) return "lam_g";
      break;
    case SCHEME_HessLagOutput: 
      if(i==0) return "hess";
      if(i==1) return "f";
      if(i==2) return "g";
      if(i==3) return "grad_x";
      if(i==4) return "grad_p";
      break;
    case SCHEME_NLPSolverInput: 
      if(i==0) return "x0";
      if(i==1) return "p";
      if(i==2) return "lbx";
      if(i==3) return "ubx";
      if(i==4) return "lbg";
      if(i==5) return "ubg";
      if(i==6) return "lam_x0";
      if(i==7) return "lam_g0";
      break;
    case SCHEME_NLPSolverOutput: 
      if(i==0) return "x";
      if(i==1) return "f";
      if(i==2) return "g";
      if(i==3) return "lam_x";
      if(i==4) return "lam_g";
      if(i==5) return "lam_p";
      break;
    case SCHEME_MayerInput: 
      if(i==0) return "x";
      if(i==1) return "p";
      break;
    case SCHEME_OCPInput: 
      if(i==0) return "lbx";
      if(i==1) return "ubx";
      if(i==2) return "x_init";
      if(i==3) return "lbu";
      if(i==4) return "ubu";
      if(i==5) return "u_init";
      if(i==6) return "lbp";
      if(i==7) return "ubp";
      if(i==8) return "p_init";
      if(i==9) return "lbh";
      if(i==10) return "ubh";
      if(i==11) return "lbg";
      if(i==12) return "ubg";
      break;
    case SCHEME_OCPOutput: 
      if(i==0) return "x_opt";
      if(i==1) return "u_opt";
      if(i==2) return "p_opt";
      if(i==3) return "cost";
      break;
    case SCHEME_QPInput: 
      if(i==0) return "h";
      if(i==1) return "g";
      if(i==2) return "a";
      if(i==3) return "lba";
      if(i==4) return "uba";
      if(i==5) return "lbx";
      if(i==6) return "ubx";
      if(i==7) return "x_init";
      if(i==8) return "lambda_init";
      break;
    case SCHEME_QPOutput: 
      if(i==0) return "primal";
      if(i==1) return "cost";
      if(i==2) return "lambda_a";
      if(i==3) return "lambda_x";
      break;
    case SCHEME_SDPInput: 
      if(i==0) return "a";
      if(i==1) return "b";
      if(i==2) return "c";
      break;
    case SCHEME_SDPOutput: 
      if(i==0) return "primal";
      if(i==1) return "p";
      if(i==2) return "dual";
      if(i==3) return "primal_cost";
      if(i==4) return "dual_cost";
      break;
    case SCHEME_unknown: return "none";
  }
  casadi_error("getSchemeEntryName: supplied number is out of range. Scheme '" << getSchemeName(scheme) << "' has only " << getSchemeSize(scheme) << " entries: " << getSchemeEntryNames(scheme) << ".");
}
std::string getSchemeEntryDoc(InputOutputScheme scheme, int i) {
  switch (scheme) {
    case SCHEME_ACADO_Input: 
      if(i==0) return "Initial guess for x (default: 0)";
      if(i==1) return "Initial guess for u (default: 0)";
      if(i==2) return "Initial guess for p (default: 0)";
      if(i==3) return "Lower bound on x (default:  -infinity)";
      if(i==4) return "Upper bound on x (default:  infinity)";
      if(i==5) return "Lower bound on x0 (default:  -infinity)";
      if(i==6) return "Upper bound on x0 (default:  infinity)";
      if(i==7) return "Lower bound on xf (default:  -infinity)";
      if(i==8) return "Upper bound on xf (default:  infinity)";
      if(i==9) return "Lower bound on u (default:  -infinity)";
      if(i==10) return "Upper bound on u (default:  infinity)";
      if(i==11) return "Lower bound on p (default:  -infinity)";
      if(i==12) return "Upper bound on p (default:  infinity)";
      if(i==13) return "Lower bound on the path constraint function (default:  -infinity)";
      if(i==14) return "Upper bound on the path constraint function (default:  infinity)";
      if(i==15) return "Lower bound on the initial constraint function (default:  0)";
      if(i==16) return "Upper bound on the initial constraint function (default:  0)";
      break;
    case SCHEME_ACADO_Output: 
      if(i==0) return "Optimal states";
      if(i==1) return "Optimal control inputs";
      if(i==2) return "Optimal parameters";
      if(i==3) return "Optimal cost";
      break;
    case SCHEME_ACADO_FCN_Input: 
      if(i==0) return "Time";
      if(i==1) return "Differential state";
      if(i==2) return "Algebraic state";
      if(i==3) return "Control input";
      if(i==4) return "Parameter";
      if(i==5) return "Differential state derivative";
      break;
    case SCHEME_ControlledDAEInput: 
      if(i==0) return "Global physical time. (1-by-1)";
      if(i==1) return "State vector (dimension nx-by-1). Should have same amount of non-zeros as DAEOutput:DAE_RES";
      if(i==2) return "Algebraic state vector (dimension np-by-1).";
      if(i==3) return "Parameter vector (dimension np-by-1).";
      if(i==4) return "Control vector (dimension nu-by-1).";
      if(i==5) return "Control vector, linearly interpolated (dimension nu-by-1).";
      if(i==6) return "State vector (dimension nx-by-1) at the last major time-step";
      if(i==7) return "Time at start of control interval (1-by-1)";
      if(i==8) return "Time at end of control interval (1-by-1)";
      break;
    case SCHEME_ControlSimulatorInput: 
      if(i==0) return "Differential or algebraic state at t0  (dimension nx-by-1)";
      if(i==1) return "Parameters that are fixed over the entire horizon  (dimension np-by-1)";
      if(i==2) return "Parameters that change over the integration intervals (dimension (ns-1)-by-nu)";
      break;
    case SCHEME_DAEInput: 
      if(i==0) return "Differential state";
      if(i==1) return "Algebraic state";
      if(i==2) return "Parameter";
      if(i==3) return "Explicit time dependence";
      break;
    case SCHEME_DAEOutput: 
      if(i==0) return "Right hand side of the implicit ODE";
      if(i==1) return "Right hand side of algebraic equations";
      if(i==2) return "Right hand side of quadratures equations";
      break;
    case SCHEME_RDAEInput: 
      if(i==0) return "Backward differential state";
      if(i==1) return "Backward algebraic state";
      if(i==2) return "Backward  parameter vector";
      if(i==3) return "Forward differential state";
      if(i==4) return "Forward algebraic state";
      if(i==5) return "Parameter vector";
      if(i==6) return "Explicit time dependence";
      break;
    case SCHEME_RDAEOutput: 
      if(i==0) return "Right hand side of ODE.";
      if(i==1) return "Right hand side of algebraic equations.";
      if(i==2) return "Right hand side of quadratures.";
      break;
    case SCHEME_IntegratorInput: 
      if(i==0) return "Differential state at the initial time";
      if(i==1) return "Parameters";
      if(i==2) return "Backward differential state at the final time";
      if(i==3) return "Backward parameter vector";
      break;
    case SCHEME_IntegratorOutput: 
      if(i==0) return "Differential state at the final time";
      if(i==1) return "Quadrature state at the final time";
      if(i==2) return "Backward differential state at the initial time";
      if(i==3) return "Backward quadrature state at the initial time";
      break;
    case SCHEME_NLPInput: 
      if(i==0) return "Decision variable";
      if(i==1) return "Fixed parameter";
      break;
    case SCHEME_NLPOutput: 
      if(i==0) return "Objective function";
      if(i==1) return "Constraint function";
      break;
    case SCHEME_GradFInput: 
      if(i==0) return "Decision variable";
      if(i==1) return "Fixed parameter";
      break;
    case SCHEME_GradFOutput: 
      if(i==0) return "Jacobian of the constraints";
      if(i==1) return "Objective function";
      if(i==2) return "Constraint function";
      break;
    case SCHEME_JacGInput: 
      if(i==0) return "Decision variable";
      if(i==1) return "Fixed parameter";
      break;
    case SCHEME_JacGOutput: 
      if(i==0) return "Jacobian of the constraints";
      if(i==1) return "Objective function";
      if(i==2) return "Constraint function";
      break;
    case SCHEME_HessLagInput: 
      if(i==0) return "Decision variable";
      if(i==1) return "Fixed parameter";
      if(i==2) return "Multiplier for f";
      if(i==3) return "Multiplier for g";
      break;
    case SCHEME_HessLagOutput: 
      if(i==0) return "Hessian of the Lagrangian";
      if(i==1) return "Objective function";
      if(i==2) return "Constraint function";
      if(i==3) return "Gradient of the Lagrangian with respect to x";
      if(i==4) return "Gradient of the Lagrangian with respect to p";
      break;
    case SCHEME_NLPSolverInput: 
      if(i==0) return "Decision variables, initial guess (nx x 1) ";
      if(i==1) return "Value of fixed parameters (np x 1)";
      if(i==2) return "Decision variables lower bound (nx x 1), default -inf";
      if(i==3) return "Decision variables upper bound (nx x 1), default +inf";
      if(i==4) return "Constraints lower bound (ng x 1), default -inf";
      if(i==5) return "Constraints upper bound (ng x 1), default +inf";
      if(i==6) return "Lagrange multipliers for bounds on X, initial guess (nx x 1)";
      if(i==7) return "Lagrange multipliers for bounds on G, initial guess (ng x 1)";
      break;
    case SCHEME_NLPSolverOutput: 
      if(i==0) return "Decision variables at the optimal solution (nx x 1)";
      if(i==1) return "Cost function value at the optimal solution (1 x 1)";
      if(i==2) return "Constraints function at the optimal solution (ng x 1)";
      if(i==3) return "Lagrange multipliers for bounds on X at the solution (nx x 1)";
      if(i==4) return "Lagrange multipliers for bounds on G at the solution (ng x 1)";
      if(i==5) return "Lagrange multipliers for bounds on P at the solution (np x 1)";
      break;
    case SCHEME_MayerInput: 
      if(i==0) return "States at the end of integration (nx x 1)";
      if(i==1) return "Problem parameters (np x 1)";
      break;
    case SCHEME_OCPInput: 
      if(i==0) return "States lower bounds (nx x (ns+1))";
      if(i==1) return "States upper bounds (nx x (ns+1))";
      if(i==2) return "States initial guess (nx x (ns+1))";
      if(i==3) return "Controls lower bounds (nu x ns)";
      if(i==4) return "Controls upper bounds (nu x ns)";
      if(i==5) return "Controls initial guess (nu x ns)";
      if(i==6) return "Parameters lower bounds (np x 1)";
      if(i==7) return "Parameters upper bounds (np x 1)";
      if(i==8) return "Parameters initial guess (np x 1)";
      if(i==9) return "Point constraint lower bound (nh x (ns+1))";
      if(i==10) return "Point constraint upper bound (nh x (ns+1))";
      if(i==11) return "Lower bound for the coupling constraints";
      if(i==12) return "Upper bound for the coupling constraints";
      break;
    case SCHEME_OCPOutput: 
      if(i==0) return "Optimal state trajectory";
      if(i==1) return "Optimal control trajectory";
      if(i==2) return "Optimal parameters";
      if(i==3) return "Objective/cost function for optimal solution (1 x 1)";
      break;
    case SCHEME_QPInput: 
      if(i==0) return "The square matrix H: sparse, (nx x nx). Only the lower triangular part is actually used. The matrix is assumed to be symmetrical.";
      if(i==1) return "The vector G: dense,  (nx x 1)";
      if(i==2) return "The matrix A: sparse, (nc x nx) - product with x must be dense.";
      if(i==3) return "dense, (nc x 1)";
      if(i==4) return "dense, (nc x 1)";
      if(i==5) return "dense, (nx x 1)";
      if(i==6) return "dense, (nx x 1)";
      if(i==7) return "dense, (nx x 1)";
      if(i==8) return "dense";
      break;
    case SCHEME_QPOutput: 
      if(i==0) return "The primal solution";
      if(i==1) return "The optimal cost";
      if(i==2) return "The dual solution corresponding to linear bounds";
      if(i==3) return "The dual solution corresponding to simple bounds";
      break;
    case SCHEME_SDPInput: 
      if(i==0) return "The vertical stack of all matrices A_i: ( nm x n)";
      if(i==1) return "The vector b: ( m x 1)";
      if(i==2) return "The matrix C: ( n x n)";
      break;
    case SCHEME_SDPOutput: 
      if(i==0) return "The primal solution (m x 1) - may be used as initial guess";
      if(i==1) return "The solution P (n x n) - may be used as initial guess";
      if(i==2) return "The dual solution (n x n) - may be used as initial guess";
      if(i==3) return "The primal optimal cost (1 x 1)";
      if(i==4) return "The dual optimal cost (1 x 1)";
      break;
    case SCHEME_unknown: return "none";
  }
  casadi_error("getSchemeEntryDoc: supplied number is out of range. Scheme '" << getSchemeName(scheme) << "' has only " << getSchemeSize(scheme) << " entries: " << getSchemeEntryNames(scheme) << ".");
}
std::string getSchemeEntryEnumName(InputOutputScheme scheme, int i) {
  switch (scheme) {
    case SCHEME_ACADO_Input: 
      if(i==0) return "ACADO_X_GUESS";
      if(i==1) return "ACADO_U_GUESS";
      if(i==2) return "ACADO_P_GUESS";
      if(i==3) return "ACADO_LBX";
      if(i==4) return "ACADO_UBX";
      if(i==5) return "ACADO_LBX0";
      if(i==6) return "ACADO_UBX0";
      if(i==7) return "ACADO_LBXF";
      if(i==8) return "ACADO_UBXF";
      if(i==9) return "ACADO_LBU";
      if(i==10) return "ACADO_UBU";
      if(i==11) return "ACADO_LBP";
      if(i==12) return "ACADO_UBP";
      if(i==13) return "ACADO_LBC";
      if(i==14) return "ACADO_UBC";
      if(i==15) return "ACADO_LBR";
      if(i==16) return "ACADO_UBR";
      break;
    case SCHEME_ACADO_Output: 
      if(i==0) return "ACADO_X_OPT";
      if(i==1) return "ACADO_U_OPT";
      if(i==2) return "ACADO_P_OPT";
      if(i==3) return "ACADO_COST";
      break;
    case SCHEME_ACADO_FCN_Input: 
      if(i==0) return "ACADO_FCN_T";
      if(i==1) return "ACADO_FCN_XD";
      if(i==2) return "ACADO_FCN_XA";
      if(i==3) return "ACADO_FCN_U";
      if(i==4) return "ACADO_FCN_P";
      if(i==5) return "ACADO_FCN_XDOT";
      break;
    case SCHEME_ControlledDAEInput: 
      if(i==0) return "CONTROL_DAE_T";
      if(i==1) return "CONTROL_DAE_X";
      if(i==2) return "CONTROL_DAE_Z";
      if(i==3) return "CONTROL_DAE_P";
      if(i==4) return "CONTROL_DAE_U";
      if(i==5) return "CONTROL_DAE_U_INTERP";
      if(i==6) return "CONTROL_DAE_X_MAJOR";
      if(i==7) return "CONTROL_DAE_T0";
      if(i==8) return "CONTROL_DAE_TF";
      break;
    case SCHEME_ControlSimulatorInput: 
      if(i==0) return "CONTROLSIMULATOR_X0";
      if(i==1) return "CONTROLSIMULATOR_P";
      if(i==2) return "CONTROLSIMULATOR_U";
      break;
    case SCHEME_DAEInput: 
      if(i==0) return "DAE_X";
      if(i==1) return "DAE_Z";
      if(i==2) return "DAE_P";
      if(i==3) return "DAE_T";
      break;
    case SCHEME_DAEOutput: 
      if(i==0) return "DAE_ODE";
      if(i==1) return "DAE_ALG";
      if(i==2) return "DAE_QUAD";
      break;
    case SCHEME_RDAEInput: 
      if(i==0) return "RDAE_RX";
      if(i==1) return "RDAE_RZ";
      if(i==2) return "RDAE_RP";
      if(i==3) return "RDAE_X";
      if(i==4) return "RDAE_Z";
      if(i==5) return "RDAE_P";
      if(i==6) return "RDAE_T";
      break;
    case SCHEME_RDAEOutput: 
      if(i==0) return "RDAE_ODE";
      if(i==1) return "RDAE_ALG";
      if(i==2) return "RDAE_QUAD";
      break;
    case SCHEME_IntegratorInput: 
      if(i==0) return "INTEGRATOR_X0";
      if(i==1) return "INTEGRATOR_P";
      if(i==2) return "INTEGRATOR_RX0";
      if(i==3) return "INTEGRATOR_RP";
      break;
    case SCHEME_IntegratorOutput: 
      if(i==0) return "INTEGRATOR_XF";
      if(i==1) return "INTEGRATOR_QF";
      if(i==2) return "INTEGRATOR_RXF";
      if(i==3) return "INTEGRATOR_RQF";
      break;
    case SCHEME_NLPInput: 
      if(i==0) return "NLP_X";
      if(i==1) return "NLP_P";
      break;
    case SCHEME_NLPOutput: 
      if(i==0) return "NLP_F";
      if(i==1) return "NLP_G";
      break;
    case SCHEME_GradFInput: 
      if(i==0) return "GRADF_X";
      if(i==1) return "GRADF_P";
      break;
    case SCHEME_GradFOutput: 
      if(i==0) return "GRADF_GRAD";
      if(i==1) return "GRADF_F";
      if(i==2) return "GRADF_G";
      break;
    case SCHEME_JacGInput: 
      if(i==0) return "JACG_X";
      if(i==1) return "JACG_P";
      break;
    case SCHEME_JacGOutput: 
      if(i==0) return "JACG_JAC";
      if(i==1) return "JACG_F";
      if(i==2) return "JACG_G";
      break;
    case SCHEME_HessLagInput: 
      if(i==0) return "HESSLAG_X";
      if(i==1) return "HESSLAG_P";
      if(i==2) return "HESSLAG_LAM_F";
      if(i==3) return "HESSLAG_LAM_G";
      break;
    case SCHEME_HessLagOutput: 
      if(i==0) return "HESSLAG_HESS";
      if(i==1) return "HESSLAG_F";
      if(i==2) return "HESSLAG_G";
      if(i==3) return "HESSLAG_GRAD_X";
      if(i==4) return "HESSLAG_GRAD_P";
      break;
    case SCHEME_NLPSolverInput: 
      if(i==0) return "NLP_SOLVER_X0";
      if(i==1) return "NLP_SOLVER_P";
      if(i==2) return "NLP_SOLVER_LBX";
      if(i==3) return "NLP_SOLVER_UBX";
      if(i==4) return "NLP_SOLVER_LBG";
      if(i==5) return "NLP_SOLVER_UBG";
      if(i==6) return "NLP_SOLVER_LAM_X0";
      if(i==7) return "NLP_SOLVER_LAM_G0";
      break;
    case SCHEME_NLPSolverOutput: 
      if(i==0) return "NLP_SOLVER_X";
      if(i==1) return "NLP_SOLVER_F";
      if(i==2) return "NLP_SOLVER_G";
      if(i==3) return "NLP_SOLVER_LAM_X";
      if(i==4) return "NLP_SOLVER_LAM_G";
      if(i==5) return "NLP_SOLVER_LAM_P";
      break;
    case SCHEME_MayerInput: 
      if(i==0) return "MAYER_X";
      if(i==1) return "MAYER_P";
      break;
    case SCHEME_OCPInput: 
      if(i==0) return "OCP_LBX";
      if(i==1) return "OCP_UBX";
      if(i==2) return "OCP_X_INIT";
      if(i==3) return "OCP_LBU";
      if(i==4) return "OCP_UBU";
      if(i==5) return "OCP_U_INIT";
      if(i==6) return "OCP_LBP";
      if(i==7) return "OCP_UBP";
      if(i==8) return "OCP_P_INIT";
      if(i==9) return "OCP_LBH";
      if(i==10) return "OCP_UBH";
      if(i==11) return "OCP_LBG";
      if(i==12) return "OCP_UBG";
      break;
    case SCHEME_OCPOutput: 
      if(i==0) return "OCP_X_OPT";
      if(i==1) return "OCP_U_OPT";
      if(i==2) return "OCP_P_OPT";
      if(i==3) return "OCP_COST";
      break;
    case SCHEME_QPInput: 
      if(i==0) return "QP_H";
      if(i==1) return "QP_G";
      if(i==2) return "QP_A";
      if(i==3) return "QP_LBA";
      if(i==4) return "QP_UBA";
      if(i==5) return "QP_LBX";
      if(i==6) return "QP_UBX";
      if(i==7) return "QP_X_INIT";
      if(i==8) return "QP_LAMBDA_INIT";
      break;
    case SCHEME_QPOutput: 
      if(i==0) return "QP_PRIMAL";
      if(i==1) return "QP_COST";
      if(i==2) return "QP_LAMBDA_A";
      if(i==3) return "QP_LAMBDA_X";
      break;
    case SCHEME_SDPInput: 
      if(i==0) return "SDP_A";
      if(i==1) return "SDP_B";
      if(i==2) return "SDP_C";
      break;
    case SCHEME_SDPOutput: 
      if(i==0) return "SDP_PRIMAL";
      if(i==1) return "SDP_PRIMAL_P";
      if(i==2) return "SDP_DUAL";
      if(i==3) return "SDP_PRIMAL_COST";
      if(i==4) return "SDP_DUAL_COST";
      break;
    case SCHEME_unknown: return "none";
  }
  casadi_error("getSchemeEntryEnumName: supplied number is out of range. Scheme '" << getSchemeName(scheme) << "' has only " << getSchemeSize(scheme) << " entries: " << getSchemeEntryNames(scheme) << ".");
}
int getSchemeSize(InputOutputScheme scheme) {
  switch (scheme) {
    case SCHEME_ACADO_Input: 
      return 17;
      break;
    case SCHEME_ACADO_Output: 
      return 4;
      break;
    case SCHEME_ACADO_FCN_Input: 
      return 6;
      break;
    case SCHEME_ControlledDAEInput: 
      return 9;
      break;
    case SCHEME_ControlSimulatorInput: 
      return 3;
      break;
    case SCHEME_DAEInput: 
      return 4;
      break;
    case SCHEME_DAEOutput: 
      return 3;
      break;
    case SCHEME_RDAEInput: 
      return 7;
      break;
    case SCHEME_RDAEOutput: 
      return 3;
      break;
    case SCHEME_IntegratorInput: 
      return 4;
      break;
    case SCHEME_IntegratorOutput: 
      return 4;
      break;
    case SCHEME_NLPInput: 
      return 2;
      break;
    case SCHEME_NLPOutput: 
      return 2;
      break;
    case SCHEME_GradFInput: 
      return 2;
      break;
    case SCHEME_GradFOutput: 
      return 3;
      break;
    case SCHEME_JacGInput: 
      return 2;
      break;
    case SCHEME_JacGOutput: 
      return 3;
      break;
    case SCHEME_HessLagInput: 
      return 4;
      break;
    case SCHEME_HessLagOutput: 
      return 5;
      break;
    case SCHEME_NLPSolverInput: 
      return 8;
      break;
    case SCHEME_NLPSolverOutput: 
      return 6;
      break;
    case SCHEME_MayerInput: 
      return 2;
      break;
    case SCHEME_OCPInput: 
      return 13;
      break;
    case SCHEME_OCPOutput: 
      return 4;
      break;
    case SCHEME_QPInput: 
      return 9;
      break;
    case SCHEME_QPOutput: 
      return 4;
      break;
    case SCHEME_SDPInput: 
      return 3;
      break;
    case SCHEME_SDPOutput: 
      return 5;
      break;
    case SCHEME_unknown: casadi_error("getSchemeSize: Unknown scheme has no known size."); return -1;
  }
}
int getSchemeEntryEnum(InputOutputScheme scheme, const std::string &name) {
  switch (scheme) {
    case SCHEME_ACADO_Input: 
      if(name=="x_guess") return 0;
      if(name=="u_guess") return 1;
      if(name=="p_guess") return 2;
      if(name=="lbx") return 3;
      if(name=="ubx") return 4;
      if(name=="lbx0") return 5;
      if(name=="ubx0") return 6;
      if(name=="lbxf") return 7;
      if(name=="ubxf") return 8;
      if(name=="lbu") return 9;
      if(name=="ubu") return 10;
      if(name=="lbp") return 11;
      if(name=="ubp") return 12;
      if(name=="lbc") return 13;
      if(name=="ubc") return 14;
      if(name=="lbr") return 15;
      if(name=="ubr") return 16;
      break;
    case SCHEME_ACADO_Output: 
      if(name=="x_opt") return 0;
      if(name=="u_opt") return 1;
      if(name=="p_opt") return 2;
      if(name=="cost") return 3;
      break;
    case SCHEME_ACADO_FCN_Input: 
      if(name=="t") return 0;
      if(name=="xd") return 1;
      if(name=="xa") return 2;
      if(name=="u") return 3;
      if(name=="p") return 4;
      if(name=="xdot") return 5;
      break;
    case SCHEME_ControlledDAEInput: 
      if(name=="t") return 0;
      if(name=="x") return 1;
      if(name=="z") return 2;
      if(name=="p") return 3;
      if(name=="u") return 4;
      if(name=="u_interp") return 5;
      if(name=="x_major") return 6;
      if(name=="t0") return 7;
      if(name=="tf") return 8;
      break;
    case SCHEME_ControlSimulatorInput: 
      if(name=="x0") return 0;
      if(name=="p") return 1;
      if(name=="u") return 2;
      break;
    case SCHEME_DAEInput: 
      if(name=="x") return 0;
      if(name=="z") return 1;
      if(name=="p") return 2;
      if(name=="t") return 3;
      break;
    case SCHEME_DAEOutput: 
      if(name=="ode") return 0;
      if(name=="alg") return 1;
      if(name=="quad") return 2;
      break;
    case SCHEME_RDAEInput: 
      if(name=="rx") return 0;
      if(name=="rz") return 1;
      if(name=="rp") return 2;
      if(name=="x") return 3;
      if(name=="z") return 4;
      if(name=="p") return 5;
      if(name=="t") return 6;
      break;
    case SCHEME_RDAEOutput: 
      if(name=="ode") return 0;
      if(name=="alg") return 1;
      if(name=="quad") return 2;
      break;
    case SCHEME_IntegratorInput: 
      if(name=="x0") return 0;
      if(name=="p") return 1;
      if(name=="rx0") return 2;
      if(name=="rp") return 3;
      break;
    case SCHEME_IntegratorOutput: 
      if(name=="xf") return 0;
      if(name=="qf") return 1;
      if(name=="rxf") return 2;
      if(name=="rqf") return 3;
      break;
    case SCHEME_NLPInput: 
      if(name=="x") return 0;
      if(name=="p") return 1;
      break;
    case SCHEME_NLPOutput: 
      if(name=="f") return 0;
      if(name=="g") return 1;
      break;
    case SCHEME_GradFInput: 
      if(name=="x") return 0;
      if(name=="p") return 1;
      break;
    case SCHEME_GradFOutput: 
      if(name=="grad") return 0;
      if(name=="f") return 1;
      if(name=="g") return 2;
      break;
    case SCHEME_JacGInput: 
      if(name=="x") return 0;
      if(name=="p") return 1;
      break;
    case SCHEME_JacGOutput: 
      if(name=="jac") return 0;
      if(name=="f") return 1;
      if(name=="g") return 2;
      break;
    case SCHEME_HessLagInput: 
      if(name=="x") return 0;
      if(name=="p") return 1;
      if(name=="lam_f") return 2;
      if(name=="lam_g") return 3;
      break;
    case SCHEME_HessLagOutput: 
      if(name=="hess") return 0;
      if(name=="f") return 1;
      if(name=="g") return 2;
      if(name=="grad_x") return 3;
      if(name=="grad_p") return 4;
      break;
    case SCHEME_NLPSolverInput: 
      if(name=="x0") return 0;
      if(name=="p") return 1;
      if(name=="lbx") return 2;
      if(name=="ubx") return 3;
      if(name=="lbg") return 4;
      if(name=="ubg") return 5;
      if(name=="lam_x0") return 6;
      if(name=="lam_g0") return 7;
      break;
    case SCHEME_NLPSolverOutput: 
      if(name=="x") return 0;
      if(name=="f") return 1;
      if(name=="g") return 2;
      if(name=="lam_x") return 3;
      if(name=="lam_g") return 4;
      if(name=="lam_p") return 5;
      break;
    case SCHEME_MayerInput: 
      if(name=="x") return 0;
      if(name=="p") return 1;
      break;
    case SCHEME_OCPInput: 
      if(name=="lbx") return 0;
      if(name=="ubx") return 1;
      if(name=="x_init") return 2;
      if(name=="lbu") return 3;
      if(name=="ubu") return 4;
      if(name=="u_init") return 5;
      if(name=="lbp") return 6;
      if(name=="ubp") return 7;
      if(name=="p_init") return 8;
      if(name=="lbh") return 9;
      if(name=="ubh") return 10;
      if(name=="lbg") return 11;
      if(name=="ubg") return 12;
      break;
    case SCHEME_OCPOutput: 
      if(name=="x_opt") return 0;
      if(name=="u_opt") return 1;
      if(name=="p_opt") return 2;
      if(name=="cost") return 3;
      break;
    case SCHEME_QPInput: 
      if(name=="h") return 0;
      if(name=="g") return 1;
      if(name=="a") return 2;
      if(name=="lba") return 3;
      if(name=="uba") return 4;
      if(name=="lbx") return 5;
      if(name=="ubx") return 6;
      if(name=="x_init") return 7;
      if(name=="lambda_init") return 8;
      break;
    case SCHEME_QPOutput: 
      if(name=="primal") return 0;
      if(name=="cost") return 1;
      if(name=="lambda_a") return 2;
      if(name=="lambda_x") return 3;
      break;
    case SCHEME_SDPInput: 
      if(name=="a") return 0;
      if(name=="b") return 1;
      if(name=="c") return 2;
      break;
    case SCHEME_SDPOutput: 
      if(name=="primal") return 0;
      if(name=="p") return 1;
      if(name=="dual") return 2;
      if(name=="primal_cost") return 3;
      if(name=="dual_cost") return 4;
      break;
    case SCHEME_unknown: casadi_error("Unknown scheme"); return -1;
  }
  casadi_error("getSchemeEntryEnum: Scheme '" << getSchemeName(scheme) <<  "' has no entry named '" << name <<  "'. Available entries are: " << getSchemeEntryNames(scheme) << ".");
}
}

